commit 74d62e09ba1315c0f24cef60161ddaee09482bc4
Author: Stephen Segal <ssegal@meraki.com>
Date:   Wed Jul 11 20:48:22 2018 -0700

    ITB support for ARM, i386, and x86_64

diff --git a/kexec/Makefile b/kexec/Makefile
index 92ce727..30837b6 100644
--- a/kexec/Makefile
+++ b/kexec/Makefile
@@ -28,6 +28,10 @@ KEXEC_SRCS_base += kexec/zlib.c
 KEXEC_SRCS_base += kexec/kexec-xen.c
 KEXEC_SRCS_base += kexec/symbols.c
 
+ifeq ($(ARCH),$(filter $(ARCH),arm i386 x86_64))
+KEXEC_SRCS_base += kexec/kexec-fit-core.c
+endif
+
 KEXEC_GENERATED_SRCS += $(PURGATORY_HEX_C)
 
 dist += kexec/Makefile						\
diff --git a/kexec/arch/arm/Makefile b/kexec/arch/arm/Makefile
index 4454f47..20e3d23 100644
--- a/kexec/arch/arm/Makefile
+++ b/kexec/arch/arm/Makefile
@@ -12,6 +12,7 @@ arm_MEM_REGIONS        = kexec/mem_regions.c
 arm_KEXEC_SRCS=  kexec/arch/arm/kexec-elf-rel-arm.c
 arm_KEXEC_SRCS+= kexec/arch/arm/kexec-zImage-arm.c
 arm_KEXEC_SRCS+= kexec/arch/arm/kexec-uImage-arm.c
+arm_KEXEC_SRCS+= kexec/arch/arm/kexec-fit-arm.c
 arm_KEXEC_SRCS+= kexec/arch/arm/kexec-arm.c
 arm_KEXEC_SRCS+= kexec/arch/arm/crashdump-arm.c
 arm_KEXEC_SRCS+= kexec/fs2dt.c
diff --git a/kexec/arch/arm/include/arch/options.h b/kexec/arch/arm/include/arch/options.h
index abbf349..bbd6947 100644
--- a/kexec/arch/arm/include/arch/options.h
+++ b/kexec/arch/arm/include/arch/options.h
@@ -10,6 +10,8 @@
 #define OPT_ATAGS	(OPT_ARCH_MAX+1)
 #define OPT_IMAGE_SIZE	(OPT_ARCH_MAX+2)
 #define OPT_PAGE_OFFSET	(OPT_ARCH_MAX+3)
+#define OPT_REUSE_CMDLINE	(OPT_ARCH_MAX+4)
+#define OPT_CONFIG	(OPT_ARCH_MAX+5)
 
 /* Options relevant to the architecture (excluding loader-specific ones),
  * in this case none:
@@ -43,7 +45,9 @@
 	{ "dtb",		1, 0, OPT_DTB }, 	\
 	{ "atags",		0, 0, OPT_ATAGS },	\
 	{ "image-size",		1, 0, OPT_IMAGE_SIZE }, \
-	{ "page-offset",	1, 0, OPT_PAGE_OFFSET },
+	{ "page-offset",	1, 0, OPT_PAGE_OFFSET }, \
+	{ "reuse-cmdline",	0, 0, OPT_REUSE_CMDLINE }, \
+	{ "config",			1, 0, OPT_CONFIG },
 
 #define KEXEC_ALL_OPT_STR KEXEC_ARCH_OPT_STR "a:r:s:"
 
diff --git a/kexec/arch/arm/kexec-arm.c b/kexec/arch/arm/kexec-arm.c
index 49f35b1..32a85cb 100644
--- a/kexec/arch/arm/kexec-arm.c
+++ b/kexec/arch/arm/kexec-arm.c
@@ -15,6 +15,7 @@
 #include <unistd.h>
 #include "../../kexec.h"
 #include "../../kexec-syscall.h"
+#include "../../kexec-fit-core.h"
 #include "kexec-arm.h"
 #include <arch/options.h>
 #include "../../fs2dt.h"
@@ -84,6 +85,7 @@ struct file_type file_type[] = {
 	   uncompressed images. */
 	{"uImage", uImage_arm_probe, uImage_arm_load, zImage_arm_usage},
 	{"zImage", zImage_arm_probe, zImage_arm_load, zImage_arm_usage},
+	{"fit-arm", fit_probe, fit_arm_load, fit_arm_usage},
 };
 int file_types = sizeof(file_type) / sizeof(file_type[0]);
 
diff --git a/kexec/arch/arm/kexec-arm.h b/kexec/arch/arm/kexec-arm.h
index a74cce2..ad6bdc5 100644
--- a/kexec/arch/arm/kexec-arm.h
+++ b/kexec/arch/arm/kexec-arm.h
@@ -13,10 +13,19 @@ int zImage_arm_probe(const char *buf, off_t len);
 int zImage_arm_load(int argc, char **argv, const char *buf, off_t len,
 		        struct kexec_info *info);
 void zImage_arm_usage(void);
+int do_zImage_arm_load(struct kexec_info *info,
+		const void *kernel, off_t kernel_len,
+		const char *command_line, off_t command_line_len,
+		const char *initrd, off_t initrd_len,
+		const char *dtb_buf, off_t dtb_len);
 
 int uImage_arm_probe(const char *buf, off_t len);
 int uImage_arm_load(int argc, char **argv, const char *buf, off_t len,
 		        struct kexec_info *info);
+int fit_arm_load(int argc, char **argv, const char *buf, off_t len,
+		        struct kexec_info *info);
+void fit_arm_usage(void);
+
 extern int have_sysfs_fdt(void);
 
 #endif /* KEXEC_ARM_H */
diff --git a/kexec/arch/arm/kexec-fit-arm.c b/kexec/arch/arm/kexec-fit-arm.c
new file mode 100644
index 0000000..8dbe0be
--- /dev/null
+++ b/kexec/arch/arm/kexec-fit-arm.c
@@ -0,0 +1,213 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Support for U-Boot FIT image files
+ * The kernel is expected to be a bzImage.
+ *
+ * Copyright (C) 2003-2010  Eric Biederman (ebiederm@xmission.com)
+ * Copyright (C) 2014 Cisco Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <elf.h>
+#include <boot/elf_boot.h>
+#include <ip_checksum.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "../../kexec-fit-core.h"
+#include "kexec-arm.h"
+#include <arch/options.h>
+#include <libfdt.h>
+#include <sha1.h>
+#include <sha256.h>
+#include <sha512.h>
+
+void fit_arm_usage(void)
+{
+	printf( "    --config=STRING       Force this FIT configuration.\n"
+		"    --command-line=STRING Set the kernel command line to STRING.\n"
+		"    --append=STRING       Set the kernel command line to STRING.\n"
+		"    --reuse-cmdline       Use kernel command line from running system.\n"
+		);
+}
+
+
+static int do_fit_arm_load(struct kexec_info *info,
+			   const void *fit,  off_t data_len,
+			   const char *command_line,
+			   const char *config_name)
+{
+	int images_offset;
+	int configs_offset;
+	int config_offset;
+	int len;
+	int result;
+	const char *kernel_name, *ramdisk_name, *dtb_name;
+	const char *img_command_line = NULL, *full_command_line = NULL;
+	const void *kernel_data, *ramdisk_data, *dtb_data = NULL;
+	off_t kernel_len, ramdisk_len = 0, dtb_len = 0, full_command_line_len;
+
+	images_offset = fdt_path_offset(fit, "/images");
+	if (images_offset < 0) {
+		dbgprintf("%s: error finding /images: %s\n", __func__,
+			  fdt_strerror(images_offset));
+		return -1;
+	}
+	configs_offset = fdt_path_offset(fit, "/configurations");
+	if (configs_offset < 0) {
+		dbgprintf("%s: error finding /configurations: %s\n", __func__,
+			  fdt_strerror(images_offset));
+		return -1;
+	}
+
+	if (!config_name) {
+		config_name = (const char*)
+			fdt_getprop(fit, configs_offset, "default", &len);
+		if (!config_name) {
+			dbgprintf("%s: error finding default configuration name: %s\n",
+				  __func__, fdt_strerror(len));
+			return -1;
+		}
+	}
+
+	config_offset = fdt_subnode_offset(fit, configs_offset, config_name);
+	if (config_offset < 0) {
+		dbgprintf("%s: error finding config %s: %s\n", __func__,
+			  config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	kernel_name = (const char*)
+		fdt_getprop(fit, config_offset, "kernel", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s kernel: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	ramdisk_name = (const char*)
+		fdt_getprop(fit, config_offset, "ramdisk", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s ramdisk: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+	}
+
+	dtb_name = (const char*) fdt_getprop(fit, config_offset, "fdt", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s ramdisk: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+	}
+
+	if (find_fit_subimage(fit, images_offset, kernel_name,
+			      &kernel_data, &kernel_len, NULL, NULL, NULL, "arm") < 0)
+		return -1;
+
+	if (ramdisk_name)
+		if (find_fit_subimage(fit, images_offset, ramdisk_name,
+				      &ramdisk_data, &ramdisk_len, NULL, NULL, NULL, "arm") < 0)
+			return -1;
+
+	if (dtb_name)
+		if (find_fit_subimage(fit, images_offset, dtb_name,
+				      &dtb_data, &dtb_len, NULL, NULL, NULL, "arm") < 0)
+			return -1;
+
+	img_command_line = (const char*)
+		fdt_getprop(fit, config_offset, "command-line", &len);
+
+	full_command_line = concat_cmdline(img_command_line, command_line);
+	if (full_command_line) {
+		full_command_line_len = strlen(full_command_line) +1;
+	} else {
+		full_command_line = strdup("\0");
+		full_command_line_len = 1;
+	}
+
+	result = do_zImage_arm_load(info,
+				    (const char*)kernel_data,
+				    kernel_len,
+				    full_command_line,
+				    full_command_line_len,
+				    (const char*)ramdisk_data,
+				    ramdisk_len,
+				    (const char*)dtb_data,
+				    dtb_len);
+
+	free((void *)full_command_line);
+	return result;
+}
+
+
+int fit_arm_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info* info)
+{
+	char *command_line = NULL;
+	char *tmp_cmdline = NULL;
+	const char *append = NULL;
+	char *config = NULL;
+	int opt;
+	int result;
+
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ "command-line",	1, 0, OPT_APPEND },
+		{ "append",		1, 0, OPT_APPEND },
+		{ "reuse-cmdline",	0, 0, OPT_REUSE_CMDLINE },
+		{ "config",             1, 0, OPT_CONFIG },
+		{ 0,                    0, 0, 0},
+	};
+	static const char short_options[] = KEXEC_ARCH_OPT_STR "d";
+
+	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch(opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_ARCH_MAX) {
+				break;
+			}
+		case OPT_APPEND:
+			append = optarg;
+			break;
+		case OPT_REUSE_CMDLINE:
+			tmp_cmdline = get_command_line();
+			break;
+		case OPT_CONFIG:
+			config = optarg;
+			break;
+		}
+	}
+	command_line = concat_cmdline(tmp_cmdline, append);
+	if (tmp_cmdline) {
+		free(tmp_cmdline);
+	}
+
+	result = do_fit_arm_load(info,
+				 buf, len,
+				 command_line,
+				 config);
+	free(command_line);
+	return result;
+}
diff --git a/kexec/arch/arm/kexec-zImage-arm.c b/kexec/arch/arm/kexec-zImage-arm.c
index a8c40cb..370ac77 100644
--- a/kexec/arch/arm/kexec-zImage-arm.c
+++ b/kexec/arch/arm/kexec-zImage-arm.c
@@ -355,8 +355,84 @@ static int setup_dtb_prop(char **bufp, off_t *sizep, int parentoffset,
 	return 0;
 }
 
+int do_zImage_arm_load(struct kexec_info *info,
+        const void *kernel, off_t kernel_len,
+        const char *command_line, off_t command_line_len,
+        const char *initrd, off_t initrd_len,
+        const char *dtb_buf, off_t dtb_len)
+{
+	unsigned long base;
+	off_t dtb_offset;
+	unsigned int extra_size = 0x8000; /* TEXT_OFFSET */
+	char *dtb_buf_cpy;
+	off_t dtb_len_cpy;
+
+	base = locate_hole(info, kernel_len + extra_size, 0, 0,
+			   ULONG_MAX, INT_MAX);
+
+	if (base == ULONG_MAX)
+		return -1;
+
+	initrd_base = base + _ALIGN(kernel_len * 4, getpagesize());
+
+	/*
+	 * Read a user-specified DTB file.
+	 */
+	if (fdt_check_header(dtb_buf) != 0) {
+		fprintf(stderr, "Invalid FDT buffer.\n");
+		return -1;
+	}
+
+	add_segment(info, initrd, initrd_len, initrd_base, initrd_len);
+
+	/*
+	 * Tell the device tree where you put the ramfs
+	 */
+	unsigned long start, end;
+	start = cpu_to_be32((unsigned long)(initrd_base));
+	end = cpu_to_be32((unsigned long)(initrd_base + initrd_len));
+
+	/*
+	 * Copy over the device tree from our fit image buffer so we can modify it
+	 */
+	dtb_buf_cpy = xmalloc(dtb_len);
+	if (!dtb_buf_cpy)
+		return -1;
+	memcpy(dtb_buf_cpy, dtb_buf, dtb_len);
+	dtb_len_cpy = dtb_len;
+
+	if (setup_dtb_prop(&dtb_buf_cpy, &dtb_len_cpy, 0, "chosen",
+			"linux,initrd-start", &start,
+			sizeof(start))) {
+		free(dtb_buf_cpy);
+		return -1;
+	}
+	if (setup_dtb_prop(&dtb_buf_cpy, &dtb_len_cpy, 0, "chosen",
+			"linux,initrd-end", &end,
+			sizeof(end))) {
+		free(dtb_buf_cpy);
+		return -1;
+	}
+
+	/* Stick the dtb at the end of the initrd and page
+	 * align it.
+	 */
+	dtb_offset = initrd_base + initrd_len + getpagesize();
+	dtb_offset = _ALIGN_DOWN(dtb_offset, getpagesize());
+
+	add_segment(info, dtb_buf_cpy, dtb_len_cpy,
+				dtb_offset, dtb_len_cpy);
+
+	add_segment(info, kernel, kernel_len,
+				base + extra_size, kernel_len);
+
+	info->entry = (void*)base + extra_size;
+
+	return 0;
+}
+
 int zImage_arm_load(int argc, char **argv, const char *buf, off_t len,
-	struct kexec_info *info)
+		    struct kexec_info *info)
 {
 	unsigned long page_size = getpagesize();
 	unsigned long base, kernel_base;
diff --git a/kexec/arch/i386/Makefile b/kexec/arch/i386/Makefile
index d52a2f5..af7d464 100644
--- a/kexec/arch/i386/Makefile
+++ b/kexec/arch/i386/Makefile
@@ -1,6 +1,8 @@
 #
 # kexec i386 (linux booting linux)
 #
+include $(srcdir)/kexec/libfdt/Makefile.libfdt
+
 i386_KEXEC_SRCS =  kexec/arch/i386/kexec-x86.c
 i386_KEXEC_SRCS += kexec/arch/i386/kexec-x86-common.c
 i386_KEXEC_SRCS += kexec/arch/i386/kexec-elf-x86.c
@@ -11,6 +13,13 @@ i386_KEXEC_SRCS += kexec/arch/i386/kexec-beoboot-x86.c
 i386_KEXEC_SRCS += kexec/arch/i386/kexec-nbi.c
 i386_KEXEC_SRCS += kexec/arch/i386/x86-linux-setup.c
 i386_KEXEC_SRCS += kexec/arch/i386/crashdump-x86.c
+i386_KEXEC_SRCS += kexec/arch/i386/kexec-fit-x86-bzImage.c
+
+libfdt_SRCS += $(LIBFDT_SRCS:%=kexec/libfdt/%)
+
+i386_KEXEC_SRCS += $(libfdt_SRCS)
+
+i386_CPPFLAGS = -I$(srcdir)/kexec/libfdt
 
 dist += kexec/arch/i386/Makefile $(i386_KEXEC_SRCS)			\
 	kexec/arch/i386/kexec-x86.h kexec/arch/i386/crashdump-x86.h	\
diff --git a/kexec/arch/i386/include/arch/options.h b/kexec/arch/i386/include/arch/options.h
index c113a83..c55d55d 100644
--- a/kexec/arch/i386/include/arch/options.h
+++ b/kexec/arch/i386/include/arch/options.h
@@ -32,6 +32,7 @@
 #define OPT_ENTRY_32BIT		(OPT_ARCH_MAX+10)
 #define OPT_PASS_MEMMAP_CMDLINE	(OPT_ARCH_MAX+11)
 #define OPT_NOEFI		(OPT_ARCH_MAX+12)
+#define OPT_CONFIG              (OPT_ARCH_MAX+13)
 
 /* Options relevant to the architecture (excluding loader-specific ones): */
 #define KEXEC_ARCH_OPTIONS \
diff --git a/kexec/arch/i386/kexec-fit-x86-bzImage.c b/kexec/arch/i386/kexec-fit-x86-bzImage.c
new file mode 100644
index 0000000..e31b10d
--- /dev/null
+++ b/kexec/arch/i386/kexec-fit-x86-bzImage.c
@@ -0,0 +1,239 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Support for U-Boot FIT image files
+ * The kernel is expected to be a bzImage.
+ *
+ * Copyright (C) 2003-2010  Eric Biederman (ebiederm@xmission.com)
+ * Copyright (C) 2014 Cisco Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <elf.h>
+#include <boot/elf_boot.h>
+#include <ip_checksum.h>
+#include <x86/x86-linux.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "../../kexec-fit-core.h"
+#include "kexec-x86.h"
+#include "x86-linux-setup.h"
+#include "crashdump-x86.h"
+#include <arch/options.h>
+#include <libfdt.h>
+
+int fit_x86_bzImage_probe(const char *buf, off_t len)
+{
+	const void *fit;
+	int images_offset, subimage_offset, len_;
+	const char *type_name;
+
+	if (fit_probe(buf, len) == 0) {
+		fit = buf;
+		images_offset = fdt_path_offset(fit, "/images");
+		if (images_offset < 0) {
+			dbgprintf("%s: error finding /images: %s\n", __func__,
+				  fdt_strerror(images_offset));
+			return -1;
+		}
+
+		fdt_for_each_subnode(subimage_offset, fit, images_offset) {
+			type_name = (const char*)
+				fdt_getprop(fit, subimage_offset, "type", &len_);
+			if (len_ > 0 && strncmp(type_name, "x86_setup", 10) == 0) {
+				dbgprintf("%s: error found x86_setup type\n", __func__);
+				return -1;
+			}
+		}
+		return 0;
+	}
+	return -1;
+}
+
+void fit_x86_usage(void)
+{
+	printf( "    --real-mode           Use the kernels real mode entry point.\n"
+		"    --config=STRING       Force this FIT configuration.\n"
+		"    --command-line=STRING Set the kernel command line to STRING.\n"
+		"    --append=STRING       Set the kernel command line to STRING.\n"
+		"    --reuse-cmdline       Use kernel command line from running system.\n"
+		);
+}
+
+
+static int do_fit_x86_bzImage_load(struct kexec_info *info,
+                                   const void *fit,  off_t data_len,
+                                   const char *command_line,
+                                   int real_mode_entry,
+                                   const char *config_name)
+{
+	int images_offset;
+	int configs_offset;
+	int config_offset;
+	int len;
+	int result;
+	const char *kernel_name, *ramdisk_name;
+        const char *img_command_line = NULL, *full_command_line = NULL;
+	const void *kernel_data, *ramdisk_data = NULL;
+	off_t kernel_len, ramdisk_len = 0, full_command_line_len;
+
+	images_offset = fdt_path_offset(fit, "/images");
+	if (images_offset < 0) {
+		dbgprintf("%s: error finding /images: %s\n", __func__,
+			  fdt_strerror(images_offset));
+		return -1;
+	}
+	configs_offset = fdt_path_offset(fit, "/configurations");
+	if (configs_offset < 0) {
+		dbgprintf("%s: error finding /configurations: %s\n", __func__,
+			  fdt_strerror(images_offset));
+		return -1;
+	}
+
+	if (!config_name) {
+		config_name = (const char*)
+			fdt_getprop(fit, configs_offset, "default", &len);
+		if (!config_name) {
+			dbgprintf("%s: error finding default configuration name: %s\n",
+				  __func__, fdt_strerror(len));
+			return -1;
+		}
+	}
+
+	config_offset = fdt_subnode_offset(fit, configs_offset, config_name);
+	if (config_offset < 0) {
+		dbgprintf("%s: error finding config %s: %s\n", __func__,
+			  config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	kernel_name = (const char*)
+		fdt_getprop(fit, config_offset, "kernel", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s kernel: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	ramdisk_name = (const char*)
+		fdt_getprop(fit, config_offset, "ramdisk", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s ramdisk: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+	}
+
+	if (find_fit_subimage(fit, images_offset, kernel_name,
+			      &kernel_data, &kernel_len, NULL, NULL, NULL, "x86") < 0)
+		return -1;
+
+	if (ramdisk_name)
+		if (find_fit_subimage(fit, images_offset, ramdisk_name,
+				      &ramdisk_data, &ramdisk_len, NULL, NULL, NULL, "x86") < 0)
+			return -1;
+
+	img_command_line = (const char*)
+		fdt_getprop(fit, config_offset, "command-line", &len);
+
+	full_command_line = concat_cmdline(img_command_line, command_line);
+	if (full_command_line) {
+		full_command_line_len = strlen(full_command_line) +1;
+	} else {
+		full_command_line = strdup("\0");
+		full_command_line_len = 1;
+	}
+
+	result = do_bzImage_load(info,
+				 (const char*)kernel_data,
+				 kernel_len,
+				 full_command_line,
+				 full_command_line_len,
+				 (const char*)ramdisk_data,
+				 ramdisk_len,
+				 real_mode_entry);
+
+	free((void *)full_command_line);
+	return result;;
+}
+
+
+int fit_x86_bzImage_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info* info)
+{
+	char *command_line = NULL;
+	char *tmp_cmdline = NULL;
+	const char *append = NULL;
+	char *config = NULL;
+	int opt;
+	int result;
+	int real_mode_entry = 0;
+
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ "command-line",	1, 0, OPT_APPEND },
+		{ "append",		1, 0, OPT_APPEND },
+		{ "reuse-cmdline",	0, 0, OPT_REUSE_CMDLINE },
+		{ "real-mode",          0, 0, OPT_REAL_MODE },
+		{ "config",             1, 0, OPT_CONFIG },
+		{ 0,                    0, 0, 0},
+	};
+	static const char short_options[] = KEXEC_ARCH_OPT_STR "d";
+
+	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch(opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_ARCH_MAX) {
+				break;
+			}
+		case OPT_APPEND:
+			append = optarg;
+			break;
+		case OPT_REUSE_CMDLINE:
+			tmp_cmdline = get_command_line();
+			break;
+		case OPT_REAL_MODE:
+			real_mode_entry = 1;
+			break;
+		case OPT_CONFIG:
+			config = optarg;
+			break;
+		}
+	}
+	command_line = concat_cmdline(tmp_cmdline, append);
+	if (tmp_cmdline) {
+		free(tmp_cmdline);
+	}
+
+	result = do_fit_x86_bzImage_load(info,
+					 buf, len,
+					 command_line,
+					 real_mode_entry,
+					 config);
+	free(command_line);
+	if (config != NULL)
+		free(config);
+	return result;
+}
diff --git a/kexec/arch/i386/kexec-x86.c b/kexec/arch/i386/kexec-x86.c
index fb0e6f9..1770739 100644
--- a/kexec/arch/i386/kexec-x86.c
+++ b/kexec/arch/i386/kexec-x86.c
@@ -33,6 +33,11 @@
 #include "crashdump-x86.h"
 #include <arch/options.h>
 
+/**
+ * This structure was expanded to include fit-x86-bzImage type.
+ * This is a non-standard image that was created to support booting
+ * before u-boot standardized x86 image.
+ */
 struct file_type file_type[] = {
 	{ "multiboot-x86", multiboot_x86_probe, multiboot_x86_load,
 	  multiboot_x86_usage },
@@ -40,6 +45,7 @@ struct file_type file_type[] = {
 	{ "bzImage", bzImage_probe, bzImage_load, bzImage_usage },
 	{ "beoboot-x86", beoboot_probe, beoboot_load, beoboot_usage },
 	{ "nbi-x86", nbi_probe, nbi_load, nbi_usage },
+	{ "fit-x86-bzImage", fit_x86_bzImage_probe, fit_x86_bzImage_load, fit_x86_usage },
 };
 int file_types = sizeof(file_type)/sizeof(file_type[0]);
 
diff --git a/kexec/arch/i386/kexec-x86.h b/kexec/arch/i386/kexec-x86.h
index 51855f8..c7ee5a4 100644
--- a/kexec/arch/i386/kexec-x86.h
+++ b/kexec/arch/i386/kexec-x86.h
@@ -84,5 +84,10 @@ int nbi_load(int argc, char **argv, const char *buf, off_t len,
 	struct kexec_info *info);
 void nbi_usage(void);
 
+int fit_x86_bzImage_probe(const char *buf, off_t len);
+int fit_x86_bzImage_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info *info);
+void fit_x86_usage(void);
+
 extern unsigned xen_e820_to_kexec_type(uint32_t type);
 #endif /* KEXEC_X86_H */
diff --git a/kexec/arch/x86_64/Makefile b/kexec/arch/x86_64/Makefile
index 1cf10f9..f21e61b 100644
--- a/kexec/arch/x86_64/Makefile
+++ b/kexec/arch/x86_64/Makefile
@@ -1,6 +1,8 @@
 #
 # kexec x86_64 (linux booting linux)
 #
+include $(srcdir)/kexec/libfdt/Makefile.libfdt
+
 x86_64_KEXEC_SRCS =  kexec/arch/i386/kexec-elf-x86.c
 x86_64_KEXEC_SRCS += kexec/arch/i386/kexec-bzImage.c
 x86_64_KEXEC_SRCS += kexec/arch/i386/kexec-multiboot-x86.c
@@ -9,14 +11,22 @@ x86_64_KEXEC_SRCS += kexec/arch/i386/kexec-nbi.c
 x86_64_KEXEC_SRCS += kexec/arch/i386/x86-linux-setup.c
 x86_64_KEXEC_SRCS += kexec/arch/i386/kexec-x86-common.c
 x86_64_KEXEC_SRCS += kexec/arch/i386/crashdump-x86.c
+x86_64_KEXEC_SRCS += kexec/arch/i386/kexec-fit-x86-bzImage.c
 
 x86_64_KEXEC_SRCS_native =  kexec/arch/x86_64/kexec-x86_64.c
 x86_64_KEXEC_SRCS_native += kexec/arch/x86_64/kexec-elf-x86_64.c
 x86_64_KEXEC_SRCS_native += kexec/arch/x86_64/kexec-elf-rel-x86_64.c
 x86_64_KEXEC_SRCS_native += kexec/arch/x86_64/kexec-bzImage64.c
+x86_64_KEXEC_SRCS_native += kexec/arch/x86_64/kexec-fit-x86_64.c
 
 x86_64_KEXEC_SRCS += $(x86_64_KEXEC_SRCS_native)
 
+libfdt_SRCS += $(LIBFDT_SRCS:%=kexec/libfdt/%)
+
+x86_64_KEXEC_SRCS += $(libfdt_SRCS)
+
+x86_64_CPPFLAGS = -I$(srcdir)/kexec/libfdt
+
 # Don't add sources in i386/ to dist, as i386/Makefile adds them
 dist += kexec/arch/x86_64/Makefile $(x86_64_KEXEC_SRCS_native) \
 	kexec/arch/x86_64/kexec-x86_64.h \
diff --git a/kexec/arch/x86_64/kexec-fit-x86_64.c b/kexec/arch/x86_64/kexec-fit-x86_64.c
new file mode 100644
index 0000000..64eb43b
--- /dev/null
+++ b/kexec/arch/x86_64/kexec-fit-x86_64.c
@@ -0,0 +1,403 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Support for U-Boot FIT image files
+ * The kernel is expected to be a vmlinux binary.
+ *
+ * Copyright (C) 2003-2010  Eric Biederman (ebiederm@xmission.com)
+ * Copyright (C) 2016 Cisco Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define _GNU_SOURCE
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <elf.h>
+#include <x86/x86-linux.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "../../kexec-lzma.h"
+#include "../../kexec-fit-core.h"
+#include "kexec-x86_64.h"
+#include "../i386/x86-linux-setup.h"
+#include <arch/options.h>
+#include <libfdt.h>
+
+static int do_x86_64_load(struct kexec_info *info,
+			  const void *kernel, off_t kernel_len,
+			  const void *setup, off_t setup_len,
+			  const void *initrd, off_t initrd_len,
+			  const char *command_line, off_t command_line_len)
+{
+	struct x86_linux_header setup_header;
+	struct x86_linux_param_header *real_mode;
+	int setup_sects;
+	size_t size;
+	int kern16_size;
+	unsigned long setup_base, setup_size, setup_header_size;
+	struct entry64_regs regs64;
+	unsigned long cmdline_end;
+	unsigned long align, addr, k_size;
+	unsigned kern16_size_needed;
+
+	if (sizeof(setup_header) > setup_len) {
+		fprintf(stderr, "size err x86_linux_header: %lu > %lu ?\n",
+			sizeof(setup_header), setup_len);
+		return -1;
+	}
+
+	memcpy(&setup_header, setup, sizeof(setup_header));
+	if (memcmp(&setup_header.header_magic, "HdrS", 4) != 0) {
+		fprintf(stderr, "Setup missing header magic\n");
+		return -1;
+	}
+	if (setup_header.boot_sector_magic != 0xAA55) {
+		fprintf(stderr, "No x86 boot sector present\n");
+		return -1;
+	}
+	if (setup_header.protocol_version < 0x020C) {
+		fprintf(stderr, "Must be at least protocol version 2.12\n");
+		return -1;
+	}
+
+	setup_sects = setup_header.setup_sects;
+	if (setup_sects == 0)
+		setup_sects = 4;
+	kern16_size = (setup_sects + 1) * 512;
+	if (kernel_len < kern16_size) {
+		fprintf(stderr, "Kernel truncated?\n");
+		return -1;
+	}
+
+	if ((uintmax_t)command_line_len > (uintmax_t)setup_header.cmdline_size) {
+		fprintf(stderr, "Kernel command line too long for kernel!\n");
+		return -1;
+	}
+
+	/* Taking crash dumps is not supported */
+	if (info->kexec_flags & (KEXEC_ON_CRASH | KEXEC_PRESERVE_CONTEXT)) {
+		fprintf(stderr, "Loading crash kernel is not supported!\n");
+		return -1;
+	}
+
+	/* x86_64 purgatory could be anywhere */
+	elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
+			   0x3000, -1, -1, 0);
+	dbgprintf("Loaded purgatory at addr 0x%lx\n", info->rhdr.rel_addr);
+
+	/* The argument/parameter segment */
+	kern16_size_needed = kern16_size;
+	if (kern16_size_needed < 4096)
+		kern16_size_needed = 4096;
+	setup_size = kern16_size_needed + command_line_len +
+			PURGATORY_CMDLINE_SIZE;
+	real_mode = xmalloc(setup_size);
+	memset(real_mode, 0, setup_size);
+
+	/* only copy setup_header */
+	setup_header_size = ((unsigned char *)setup)[0x201] + 0x202 - 0x1f1;
+	if (setup_header_size > 0x7f)
+		setup_header_size = 0x7f;
+	memcpy((unsigned char *)real_mode + 0x1f1, setup + 0x1f1,
+		setup_header_size);
+
+	/**
+	 * No real mode code will be executing. setup segment can be loaded
+	 * anywhere as we will be just reading command line.
+	 */
+	setup_base = add_buffer(info, real_mode, setup_size, setup_size,
+				16, 0x3000, -1, -1);
+	dbgprintf("Loaded real_mode_data and command line at 0x%lx\n",
+		  setup_base);
+
+	/* The main kernel segment */
+	k_size = kernel_len;
+	/* need to use run-time size for buffer searching */
+	dbgprintf("kernel init_size 0x%x\n", real_mode->init_size);
+	size = _ALIGN(real_mode->init_size, 4096);
+	align = real_mode->kernel_alignment;
+	addr = add_buffer(info, kernel, k_size,
+			  size, align, 0x100000, -1, -1);
+	if (addr == ULONG_MAX)
+		die("can not load flat binary");
+	dbgprintf("Loaded 64bit kernel at 0x%lx\n", addr);
+
+	/* Tell the kernel what is going on */
+	setup_linux_bootloader_parameters_high(info, real_mode, setup_base,
+					       kern16_size_needed, command_line, command_line_len,
+					       initrd, initrd_len, 1); /* put initrd high too */
+
+	elf_rel_get_symbol(&info->rhdr, "entry64_regs", &regs64,
+			  sizeof(regs64));
+	regs64.rbx = 0;           /* Bootstrap processor */
+	regs64.rsi = setup_base;  /* Pointer to the parameters */
+	regs64.rip = addr; /* the entry point for startup_64 */
+	regs64.rsp = elf_rel_get_addr(&info->rhdr, "stack_end"); /* Stack, unused */
+	elf_rel_set_symbol(&info->rhdr, "entry64_regs", &regs64,
+			   sizeof(regs64));
+
+	cmdline_end = setup_base + kern16_size_needed + command_line_len - 1;
+	elf_rel_set_symbol(&info->rhdr, "cmdline_end", &cmdline_end,
+			   sizeof(unsigned long));
+
+	/* Fill in the information BIOS calls would normally provide. */
+	setup_linux_system_parameters(info, real_mode);
+
+        return 0;
+}
+
+static void *slurp_decompress_data(const void *buffer, off_t *r_size,
+				   const char *compression)
+{
+	void *slurp_data = NULL;
+
+	if (strcmp(compression, "none") == 0) {
+		slurp_data = xmalloc(*r_size);
+		memmove(slurp_data, buffer, *r_size);
+	} else if (strcmp(compression, "lzma") == 0)
+		slurp_data = lzma_decompress_buffer(buffer, r_size);
+
+	return slurp_data;
+}
+
+static int do_fit_x86_64_load(struct kexec_info *info,
+			      const void *fit,  off_t data_len,
+			      const char *command_line,
+			      int real_mode_entry,
+			      const char *config_name)
+{
+	int images_offset;
+	int configs_offset;
+	int config_offset;
+	int len;
+	int result;
+	const char *kernel_name, *kernel_compression;
+	const char *setup_name, *setup_compression;
+	const char *ramdisk_name, *ramdisk_compression;
+	const char *img_command_line = NULL;
+	char *full_command_line = NULL;
+	const void *kernel_data = NULL, *setup_data = NULL, *ramdisk_data = NULL;
+	void *slurp_kernel_data = NULL, *slurp_setup_data = NULL, *slurp_ramdisk_data = NULL;
+	off_t kernel_len, setup_len, ramdisk_len = 0, full_command_line_len;
+
+	images_offset = fdt_path_offset(fit, "/images");
+	if (images_offset < 0) {
+		dbgprintf("%s: error finding /images: %s\n", __func__,
+			  fdt_strerror(images_offset));
+		return -1;
+	}
+	configs_offset = fdt_path_offset(fit, "/configurations");
+	if (configs_offset < 0) {
+		dbgprintf("%s: error finding /configurations: %s\n", __func__,
+			  fdt_strerror(configs_offset));
+		return -1;
+	}
+
+	if (!config_name) {
+		config_name = (const char*)
+			fdt_getprop(fit, configs_offset, "default", &len);
+		if (!config_name) {
+			dbgprintf("%s: error finding default configuration name: %s\n",
+				  __func__, fdt_strerror(len));
+			return -1;
+		}
+	}
+
+	config_offset = fdt_subnode_offset(fit, configs_offset, config_name);
+	if (config_offset < 0) {
+		dbgprintf("%s: error finding config %s: %s\n", __func__,
+			  config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	kernel_name = (const char*)
+		fdt_getprop(fit, config_offset, "kernel", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s kernel: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	setup_name = (const char*)
+		fdt_getprop(fit, config_offset, "setup", &len);
+	if (len < 0) {
+		dbgprintf("%s: error finding config %s setup: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	ramdisk_name = (const char*)
+		fdt_getprop(fit, config_offset, "ramdisk", &len);
+	if (len < 0 && len != -FDT_ERR_NOTFOUND) {
+		dbgprintf("%s: error finding config %s ramdisk: %s\n",
+			  __func__, config_name, fdt_strerror(len));
+		return -1;
+	}
+
+	if (find_fit_subimage(fit, images_offset, kernel_name,
+			      &kernel_data, &kernel_len, NULL, NULL, &kernel_compression, "x86_64") < 0)
+		return -1;
+
+	if (find_fit_subimage(fit, images_offset, setup_name,
+			      &setup_data, &setup_len, NULL, NULL, &setup_compression, "x86_64") < 0)
+		return -1;
+
+	if (ramdisk_name)
+		if (find_fit_subimage(fit, images_offset, ramdisk_name,
+				      &ramdisk_data, &ramdisk_len, NULL, NULL, &ramdisk_compression, "x86_64") < 0)
+			return -1;
+
+	img_command_line = (const char*)
+		fdt_getprop(fit, config_offset, "command-line", &len);
+
+	full_command_line = concat_cmdline(img_command_line, command_line);
+	if (full_command_line) {
+		full_command_line_len = strlen(full_command_line) +1;
+	} else {
+		full_command_line = strdup("\0");
+		full_command_line_len = 1;
+	}
+
+	slurp_kernel_data = slurp_decompress_data(kernel_data, &kernel_len, kernel_compression);
+	if (!slurp_kernel_data) {
+		dbgprintf("%s: error decompressing %s: %s is not supported\n",
+			  __func__, "kernel", kernel_compression);
+		return -1;
+	}
+
+	slurp_setup_data = slurp_decompress_data(setup_data, &setup_len, setup_compression);
+	if (!slurp_setup_data) {
+		dbgprintf("%s: error decompressing %s: %s is not supported\n",
+			  __func__, "setup", setup_compression);
+		return -1;
+	}
+
+	if (ramdisk_name) {
+		slurp_ramdisk_data = slurp_decompress_data(ramdisk_data, &ramdisk_len, ramdisk_compression);
+		if (!slurp_ramdisk_data) {
+			dbgprintf("%s: error decompressing %s: %s is not supported\n",
+				  __func__, "ramdisk", ramdisk_compression);
+			return -1;
+		}
+	}
+
+	result = do_x86_64_load(info, slurp_kernel_data, kernel_len,
+				slurp_setup_data, setup_len,
+				slurp_ramdisk_data, ramdisk_len,
+				full_command_line, full_command_line_len);
+
+	free(slurp_setup_data);
+	free((void *)full_command_line);
+	return result;
+}
+
+
+int fit_x86_64_load(int argc, char **argv, const char *buf, off_t len,
+		    struct kexec_info* info)
+{
+	char *command_line = NULL;
+	char *tmp_cmdline = NULL;
+	const char *append = NULL;
+	char *config = NULL;
+	int opt;
+	int result;
+	int real_mode_entry = 0;
+
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ "command-line",	1, 0, OPT_APPEND },
+		{ "append",		1, 0, OPT_APPEND },
+		{ "reuse-cmdline",	0, 0, OPT_REUSE_CMDLINE },
+		{ "real-mode",          0, 0, OPT_REAL_MODE },
+		{ "config",             1, 0, OPT_CONFIG },
+		{ 0,                    0, 0, 0},
+	};
+	static const char short_options[] = KEXEC_ARCH_OPT_STR "d";
+
+	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch(opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_ARCH_MAX) {
+				break;
+			}
+		case OPT_APPEND:
+			append = optarg;
+			break;
+		case OPT_REUSE_CMDLINE:
+			tmp_cmdline = get_command_line();
+			break;
+		case OPT_REAL_MODE:
+			real_mode_entry = 1;
+			break;
+		case OPT_CONFIG:
+			config = optarg;
+			break;
+		}
+	}
+	command_line = concat_cmdline(tmp_cmdline, append);
+	if (tmp_cmdline) {
+		free(tmp_cmdline);
+	}
+
+	result = do_fit_x86_64_load(info,
+				    buf, len,
+				    command_line,
+				    real_mode_entry,
+				    config);
+	free(command_line);
+	if (config != NULL)
+		free(config);
+	return result;
+}
+
+int fit_x86_64_probe(const char *buf, off_t len)
+{
+	const void *fit;
+	int images_offset, subimage_offset, arch_len, type_len;
+	const char *arch_name, *type_name;
+
+	if (fit_probe(buf, len) == 0) {
+		fit = buf;
+		images_offset = fdt_path_offset(fit, "/images");
+		if (images_offset < 0) {
+			dbgprintf("%s: error finding /images: %s\n", __func__,
+				  fdt_strerror(images_offset));
+			return -1;
+		}
+
+		fdt_for_each_subnode(subimage_offset, fit, images_offset) {
+			arch_name = (const char*)
+				fdt_getprop(fit, subimage_offset, "arch", &arch_len);
+			type_name = (const char*)
+				fdt_getprop(fit, subimage_offset, "type", &type_len);
+			if (arch_len > 0 && type_len > 0 &&
+			    strncmp(arch_name, "x86_64", 7) == 0 &&
+			    strncmp(type_name, "x86_setup", 10) == 0)
+				return 0;
+		}
+                dbgprintf("%s: error finding x86_64 arch and x86_setup type\n", __func__);
+	}
+	return -1;
+}
diff --git a/kexec/arch/x86_64/kexec-x86_64.c b/kexec/arch/x86_64/kexec-x86_64.c
index 041b007..5dcfd0e 100644
--- a/kexec/arch/x86_64/kexec-x86_64.c
+++ b/kexec/arch/x86_64/kexec-x86_64.c
@@ -28,10 +28,16 @@
 #include "../../kexec.h"
 #include "../../kexec-elf.h"
 #include "../../kexec-syscall.h"
+#include "../../kexec-fit-core.h"
 #include "kexec-x86_64.h"
 #include "../i386/crashdump-x86.h"
 #include <arch/options.h>
 
+/**
+ * This structure was expanded to include fit-x86-bzImage type.
+ * This is a non-standard image that was created to support booting
+ * before u-boot standardized x86 image.
+ */
 struct file_type file_type[] = {
 	{ "elf-x86_64", elf_x86_64_probe, elf_x86_64_load, elf_x86_64_usage },
 	{ "multiboot-x86", multiboot_x86_probe, multiboot_x86_load,
@@ -41,6 +47,8 @@ struct file_type file_type[] = {
 	{ "bzImage", bzImage_probe, bzImage_load, bzImage_usage },
 	{ "beoboot-x86", beoboot_probe, beoboot_load, beoboot_usage },
 	{ "nbi-x86", nbi_probe, nbi_load, nbi_usage },
+	{ "fit-x86-bzImage", fit_x86_bzImage_probe, fit_x86_bzImage_load, fit_x86_usage },
+	{ "fit-x86_64", fit_x86_64_probe, fit_x86_64_load, fit_x86_usage },
 };
 int file_types = sizeof(file_type)/sizeof(file_type[0]);
 
diff --git a/kexec/arch/x86_64/kexec-x86_64.h b/kexec/arch/x86_64/kexec-x86_64.h
index 4cdeffb..090622b 100644
--- a/kexec/arch/x86_64/kexec-x86_64.h
+++ b/kexec/arch/x86_64/kexec-x86_64.h
@@ -33,4 +33,8 @@ int bzImage64_load(int argc, char **argv, const char *buf, off_t len,
 			struct kexec_info *info);
 void bzImage64_usage(void);
 
+int fit_x86_64_probe(const char *buf, off_t len);
+int fit_x86_64_load(int argc, char **argv, const char *buf, off_t len,
+		    struct kexec_info *info);
+
 #endif /* KEXEC_X86_64_H */
diff --git a/kexec/kexec-fit-core.c b/kexec/kexec-fit-core.c
new file mode 100644
index 0000000..9011d2e
--- /dev/null
+++ b/kexec/kexec-fit-core.c
@@ -0,0 +1,233 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Support for U-Boot FIT image files
+ *
+ * Copyright (C) 2016 Cisco Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <arch/options.h>
+#include <libfdt.h>
+#include <sha1.h>
+#include <sha256.h>
+#include <sha512.h>
+#include "kexec.h"
+
+int fit_probe(const char* buf, off_t len)
+{
+	if (len < sizeof(struct fdt_header)) {
+		dbgprintf("File too short to be FIT image!\n");
+		return -1;
+	}
+
+	if (fdt_check_header(buf) < 0) {
+		dbgprintf("File not a FIT image\n");
+		return -1;
+	}
+
+	dbgprintf("It's a FIT image!\n");
+	return 0;
+}
+
+int
+find_fit_subimage(const void *fit, int images_offset, const char *name,
+		  const void **data, off_t *data_len,
+		  uint32_t *loadaddr,
+		  uint32_t *entryaddr,
+		  const char **compression,
+		  const char *arch)
+{
+	int len;
+	int subimage_offset;
+	int hash_offset;
+	int hash_checked = 0;
+	int depth;
+	const char* arch_;
+
+	subimage_offset = fdt_subnode_offset(fit, images_offset, name);
+	if (subimage_offset < 0) {
+		dbgprintf("%s: error finding %s: %s\n", __func__,
+			  name, fdt_strerror(subimage_offset));
+		return -1;
+	}
+
+        arch_ = (char*)fdt_getprop(fit, subimage_offset, "arch", &len);
+        if (strcmp(arch, arch_) != 0) {
+            fprintf(stderr, "%s: wrong architecture for %s (%s)", __func__,
+                    name, arch_);
+            return -1;
+        }
+	*data = fdt_getprop(fit, subimage_offset, "data", &len);
+	if (!(*data)) {
+		fprintf(stderr, "%s: error finding %s/%s: %s\n", __func__,
+			name, "data", fdt_strerror(len));
+		return -1;
+	}
+
+	*data_len = (off_t)len;
+
+	if (compression) {
+		*compression = fdt_getprop(fit, subimage_offset, "compression", &len);
+		if (!(*compression)) {
+			fprintf(stderr, "%s: error finding %s/%s: %s\n", __func__,
+				name, "compression", fdt_strerror(len));
+			return -1;
+		}
+	}
+
+	hash_offset = subimage_offset;
+	depth = 0;
+	do {
+		const char *hash_name;
+		const char *algo;
+		const char *value;
+
+		hash_offset = fdt_next_node(fit, hash_offset, &depth);
+		if (depth > 1)
+			continue;
+		if (depth < 1 || hash_offset < 0)
+			break;
+
+		hash_name = fdt_get_name(fit, hash_offset, NULL);
+
+		if (strncmp(hash_name, "hash", 4) != 0)
+			continue;
+
+		algo = (const char *)fdt_getprop(fit, hash_offset, "algo",
+						 &len);
+		if (!algo) {
+			dbgprintf("%s: error finding %s/%s/algo: %s\n", __func__,
+				  name, hash_name, fdt_strerror(len));
+		}
+
+		value = (const char *)fdt_getprop(fit, hash_offset, "value",
+						  &len);
+		if (!value) {
+			dbgprintf("%s: error finding %s/%s/value: %s\n", __func__,
+				  name, hash_name, fdt_strerror(len));
+		}
+
+		if (strcmp(algo, "sha1") == 0) {
+			sha1_context ctx;
+			uint8_t sha1_digest[SHA1_DIGEST_LENGTH];
+
+			if (len != SHA1_DIGEST_LENGTH) {
+				dbgprintf("%s: SHA1 digest length %d invalid\n",
+					  __func__, len);
+				return -1;
+			}
+
+			sha1_starts(&ctx);
+			sha1_update(&ctx, *data, *data_len);
+			sha1_finish(&ctx, sha1_digest);
+
+			if (memcmp(sha1_digest, value, SHA1_DIGEST_LENGTH) != 0) {
+				dbgprintf("%s: SHA1 mismatch\n", __func__);
+				return -1;
+			} else {
+				hash_checked = 1;
+			}
+		} else if (strcmp(algo, "sha256") == 0) {
+			sha256_context ctx;
+			sha256_digest_t sha256_digest;
+
+			if (len != sizeof(sha256_digest_t)) {
+				dbgprintf("%s: SHA256 digest length %d invalid\n",
+					  __func__, len);
+				return -1;
+			}
+
+			sha256_starts(&ctx);
+			sha256_update(&ctx, *data, *data_len);
+			sha256_finish(&ctx, sha256_digest);
+
+			if (memcmp(sha256_digest, value, sizeof(sha256_digest_t)) != 0) {
+				dbgprintf("%s: SHA256 mismatch\n", __func__);
+				return -1;
+			} else {
+				hash_checked = 1;
+			}
+		} else if (strcmp(algo, "sha512") == 0) {
+			uint8_t sha512_digest[SHA512_DIGEST_LENGTH];
+
+			if (len != SHA512_DIGEST_LENGTH) {
+				dbgprintf("%s: SHA512 digest length %d invalid\n",
+					  __func__, len);
+				return -1;
+			}
+
+			sha512(*data, *data_len, sha512_digest, 0);
+
+			if (memcmp(sha512_digest, value, SHA512_DIGEST_LENGTH) != 0) {
+				dbgprintf("%s: SHA512 mismatch\n", __func__);
+				return -1;
+			} else {
+				hash_checked = 1;
+			}
+		} else {
+			dbgprintf("%s: Ignoring unknown algorithm %s\n", __func__,
+				  algo);
+			continue;
+		}
+
+	} while (1);
+
+	if (!hash_checked) {
+		dbgprintf("%s: Warning, no hash property to check\n", __func__);
+	}
+
+	if (loadaddr) {
+		const char *load_prop = (const char *)
+			fdt_getprop(fit, subimage_offset, "load", &len);
+		if (!load_prop) {
+			dbgprintf("%s: error finding %s/%s: %s\n", __func__,
+				  name, "load", fdt_strerror(len));
+			*loadaddr = 0;
+		} else {
+			*loadaddr = (uint32_t)((load_prop[0] << 24)
+					       | (load_prop[1] << 16)
+					       | (load_prop[2] << 8)
+					       | (load_prop[3]));
+		}
+	}
+
+	if (entryaddr) {
+		const char *entry_prop = (const char *)
+			fdt_getprop(fit, subimage_offset, "entry", &len);
+		if (!entry_prop) {
+			dbgprintf("%s: error finding %s/%s: %s\n", __func__,
+				  name, "load", fdt_strerror(len));
+			*entryaddr = 0;
+		} else {
+			*entryaddr = (uint32_t)((entry_prop[0] << 24)
+						| (entry_prop[1] << 16)
+						| (entry_prop[2] << 8)
+						| (entry_prop[3]));
+		}
+	}
+
+	return 0;
+}
diff --git a/kexec/kexec-fit-core.h b/kexec/kexec-fit-core.h
new file mode 100644
index 0000000..ea62679
--- /dev/null
+++ b/kexec/kexec-fit-core.h
@@ -0,0 +1,12 @@
+#ifndef KEXEC_FIT_CORE_H
+#define KEXEC_FIT_CORE_H
+
+extern int fit_probe(const char* buf, off_t len);
+extern int find_fit_subimage(const void *fit, int images_offset, const char *name,
+			     const void **data, off_t *data_len,
+			     uint32_t *loadaddr,
+			     uint32_t *entryaddr,
+			     const char **compression,
+			     const char *arch);
+
+#endif /* KEXEC_FIT_CORE_H */
diff --git a/kexec/kexec-lzma.h b/kexec/kexec-lzma.h
index d3b751a..ece9f16 100644
--- a/kexec/kexec-lzma.h
+++ b/kexec/kexec-lzma.h
@@ -2,7 +2,9 @@
 #define __KEXEC_LZMA_H
 
 #include <sys/types.h>
+#include <stdint.h>
 
 char *lzma_decompress_file(const char *filename, off_t *r_size);
+char *lzma_decompress_buffer(const uint8_t *buffer, off_t *r_size);
 
 #endif /* __KEXEC_LZMA_H */
diff --git a/kexec/lzma.c b/kexec/lzma.c
index 5bfccb7..e936ebc 100644
--- a/kexec/lzma.c
+++ b/kexec/lzma.c
@@ -23,6 +23,8 @@ typedef struct lzfile {
 	uint8_t buf[kBufferSize];
 	lzma_stream strm;
 	FILE *file;
+	const uint8_t *buf_src;
+	off_t buf_src_len;
 	int encoding;
 	int eof;
 } LZFILE;
@@ -35,7 +37,7 @@ static LZFILE *lzopen_internal(const char *path, const char *mode, int fd)
 {
 	int level = 5;
 	int encoding = 0;
-	FILE *fp;
+	FILE *fp = NULL;
 	LZFILE *lzfile;
 	lzma_ret ret;
 	lzma_stream lzma_strm_tmp = LZMA_STREAM_INIT;
@@ -50,9 +52,9 @@ static LZFILE *lzopen_internal(const char *path, const char *mode, int fd)
 	}
 	if (fd != -1)
 		fp = fdopen(fd, encoding ? "w" : "r");
-	else
+	else if (path != NULL)
 		fp = fopen(path, encoding ? "w" : "r");
-	if (!fp)
+	if (!fp && encoding)
 		return NULL;
 
 	lzfile = calloc(1, sizeof(*lzfile));
@@ -92,6 +94,7 @@ int lzclose(LZFILE *lzfile)
 {
 	lzma_ret ret;
 	size_t n;
+	int ret_;
 
 	if (!lzfile)
 		return -1;
@@ -112,8 +115,9 @@ int lzclose(LZFILE *lzfile)
 	}
 	lzma_end(&lzfile->strm);
 
-	return fclose(lzfile->file);
+	ret_ = (lzfile->encoding ? fclose(lzfile->file) : 0);
 	free(lzfile);
+	return ret_;
 }
 
 ssize_t lzread(LZFILE *lzfile, void *buf, size_t len)
@@ -133,7 +137,26 @@ ssize_t lzread(LZFILE *lzfile, void *buf, size_t len)
 	for (;;) {
 		if (!lzfile->strm.avail_in) {
 			lzfile->strm.next_in = lzfile->buf;
-			lzfile->strm.avail_in = fread(lzfile->buf, 1, kBufferSize, lzfile->file);
+			if (lzfile->file)
+				lzfile->strm.avail_in = fread(lzfile->buf, 1, kBufferSize, lzfile->file);
+			else {
+				if (kBufferSize < lzfile->buf_src_len) {
+					memmove(lzfile->buf, lzfile->buf_src, kBufferSize);
+					lzfile->strm.avail_in = kBufferSize;
+					lzfile->buf_src += kBufferSize;
+					lzfile->buf_src_len -= kBufferSize;
+				} else {
+					if (lzfile->buf_src_len != 0) {
+						memmove(lzfile->buf, lzfile->buf_src, lzfile->buf_src_len);
+						lzfile->strm.avail_in = lzfile->buf_src_len;
+						lzfile->buf_src += lzfile->buf_src_len;
+						lzfile->buf_src_len = 0;
+					} else {
+						lzfile->strm.avail_in = 0;
+						lzfile->buf_src = NULL;
+					}
+				}
+			}
 			if (!lzfile->strm.avail_in)
 				eof = 1;
 		}
@@ -155,24 +178,13 @@ ssize_t lzread(LZFILE *lzfile, void *buf, size_t len)
 	}
 }
 
-char *lzma_decompress_file(const char *filename, off_t *r_size)
+char *lzma_decompress_helper(LZFILE *fp, off_t *r_size, const char *filename)
 {
-	LZFILE *fp;
 	char *buf;
-	off_t size, allocated;
-	ssize_t result;
-
-	dbgprintf("Try LZMA decompression.\n");
+        off_t size, allocated;
+        ssize_t result;
 
 	*r_size = 0;
-	if (!filename)
-		return NULL;
-
-	fp = lzopen(filename, "rb");
-	if (fp == 0) {
-		dbgprintf("Cannot open `%s'\n", filename);
-		return NULL;
-	}
 	size = 0;
 	allocated = 65536;
 	buf = xmalloc(allocated);
@@ -187,14 +199,14 @@ char *lzma_decompress_file(const char *filename, off_t *r_size)
 				continue;
 
 			dbgprintf("%s: read on %s of %ld bytes failed\n",
-				__func__, filename, (allocated - size) + 0UL);
+				  __func__, filename ? filename : "lzma buffer", (allocated - size) + 0UL);
 			break;
 		}
 		size += result;
 	} while (result > 0);
 
 	if (lzclose(fp) != LZMA_OK) {
-		dbgprintf("%s: Close of %s failed\n", __func__, filename);
+		dbgprintf("%s: Close of %s failed\n", __func__, filename ? filename : "lzma file");
 		goto fail;
 	}
 	if (result < 0)
@@ -206,9 +218,55 @@ fail:
 	free(buf);
 	return NULL;
 }
+
+char *lzma_decompress_file(const char *filename, off_t *r_size)
+{
+	LZFILE *fp;
+
+	dbgprintf("Try LZMA file decompression.\n");
+
+	if (!filename) {
+		*r_size = 0;
+		return NULL;
+	}
+	fp = lzopen(filename, "rb");
+	if (fp == 0) {
+		dbgprintf("%s: Cannot open `%s'\n", __func__, filename);
+		return NULL;
+	}
+
+	return lzma_decompress_helper(fp, r_size, filename);
+}
+
+char *lzma_decompress_buffer(const uint8_t *buffer, off_t *r_size)
+{
+	LZFILE *fp;
+
+        dbgprintf("Try LZMA buffer decompression.\n");
+
+	if (!buffer) {
+		*r_size = 0;
+		return NULL;
+	}
+	fp = lzopen(NULL, "rb");
+	if (fp == 0) {
+		dbgprintf("%s: Cannot open lzma file\n", __func__);
+		return NULL;
+	}
+	fp->buf_src = buffer;
+	fp->buf_src_len = *r_size;
+
+	return lzma_decompress_helper(fp, r_size, NULL);
+}
+
 #else
 char *lzma_decompress_file(const char *UNUSED(filename), off_t *UNUSED(r_size))
 {
 	return NULL;
 }
+
+char *lzma_decompress_buffer(const uint8_t *UNUSED(buffer), off_t *UNUSED(r_size))
+{
+	return NULL;
+}
 #endif /* HAVE_LIBLZMA */
diff --git a/util_lib/Makefile b/util_lib/Makefile
index 54ccdc5..5af833d 100644
--- a/util_lib/Makefile
+++ b/util_lib/Makefile
@@ -4,6 +4,8 @@
 UTIL_LIB_SRCS +=
 UTIL_LIB_SRCS += util_lib/compute_ip_checksum.c
 UTIL_LIB_SRCS += util_lib/sha256.c
+UTIL_LIB_SRCS += util_lib/sha1.c
+UTIL_LIB_SRCS += util_lib/sha512.c
 UTIL_LIB_OBJS =$(call objify, $(UTIL_LIB_SRCS))
 UTIL_LIB_DEPS =$(call depify, $(UTIL_LIB_OBJS))
 UTIL_LIB = libutil.a
@@ -12,6 +14,7 @@ UTIL_LIB = libutil.a
 
 dist  += util_lib/Makefile $(UTIL_LIB_SRCS)				\
 	util_lib/include/sha256.h util_lib/include/ip_checksum.h
+dist += util_lib/include/sha1.h util_lib/include/sha512.h
 clean += $(UTIL_LIB_OBJS) $(UTIL_LIB_DEPS) $(UTIL_LIB)
 
 $(UTIL_LIB): CPPFLAGS += -I$(srcdir)/util_lib/include
diff --git a/util_lib/include/sha1.h b/util_lib/include/sha1.h
new file mode 100644
index 0000000..cdf72a3
--- /dev/null
+++ b/util_lib/include/sha1.h
@@ -0,0 +1,20 @@
+#ifndef _SHA1_H
+#define _SHA1_H
+
+#include <inttypes.h>
+
+typedef struct
+{
+    uint32_t total[2];
+    uint32_t state[5];
+    uint8_t buffer[64];
+}
+sha1_context;
+
+#define SHA1_DIGEST_LENGTH 20
+
+void sha1_starts( sha1_context *ctx );
+void sha1_update( sha1_context *ctx, const uint8_t *input, uint32_t length );
+void sha1_finish( sha1_context *ctx, uint8_t digest[SHA1_DIGEST_LENGTH] );
+
+#endif /* sha1.h */
diff --git a/util_lib/include/sha512.h b/util_lib/include/sha512.h
new file mode 100644
index 0000000..b5d47b2
--- /dev/null
+++ b/util_lib/include/sha512.h
@@ -0,0 +1,200 @@
+/**
+ * \file sha512.h
+ *
+ * \brief SHA-384 and SHA-512 cryptographic hash function
+ *
+ *  Copyright (C) 2006-2014, ARM Limited, All Rights Reserved
+ *
+ *  This file is part of mbed TLS (https://tls.mbed.org)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef POLARSSL_SHA512_H
+#define POLARSSL_SHA512_H
+
+#include <stddef.h>
+
+#if defined(_MSC_VER) || defined(__WATCOMC__)
+  typedef unsigned __int64 uint64_t;
+#else
+  #include <inttypes.h>
+#endif
+
+#define POLARSSL_ERR_SHA512_FILE_IO_ERROR              -0x007A  /**< Read/write error in file. */
+
+#define SHA512_DIGEST_LENGTH 64
+
+#if !defined(POLARSSL_SHA512_ALT)
+// Regular implementation
+//
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          SHA-512 context structure
+ */
+typedef struct
+{
+    uint64_t total[2];          /*!< number of bytes processed  */
+    uint64_t state[8];          /*!< intermediate digest state  */
+    unsigned char buffer[128];  /*!< data block being processed */
+
+    unsigned char ipad[128];    /*!< HMAC: inner padding        */
+    unsigned char opad[128];    /*!< HMAC: outer padding        */
+    int is384;                  /*!< 0 => SHA-512, else SHA-384 */
+}
+sha512_context;
+
+/**
+ * \brief          Initialize SHA-512 context
+ *
+ * \param ctx      SHA-512 context to be initialized
+ */
+void sha512_init( sha512_context *ctx );
+
+/**
+ * \brief          Clear SHA-512 context
+ *
+ * \param ctx      SHA-512 context to be cleared
+ */
+void sha512_free( sha512_context *ctx );
+
+/**
+ * \brief          SHA-512 context setup
+ *
+ * \param ctx      context to be initialized
+ * \param is384    0 = use SHA512, 1 = use SHA384
+ */
+void sha512_starts( sha512_context *ctx, int is384 );
+
+/**
+ * \brief          SHA-512 process buffer
+ *
+ * \param ctx      SHA-512 context
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ */
+void sha512_update( sha512_context *ctx, const unsigned char *input,
+                    size_t ilen );
+
+/**
+ * \brief          SHA-512 final digest
+ *
+ * \param ctx      SHA-512 context
+ * \param output   SHA-384/512 checksum result
+ */
+void sha512_finish( sha512_context *ctx, unsigned char output[64] );
+
+#ifdef __cplusplus
+}
+#endif
+
+#else  /* POLARSSL_SHA512_ALT */
+#include "sha512_alt.h"
+#endif /* POLARSSL_SHA512_ALT */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          Output = SHA-512( input buffer )
+ *
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ * \param output   SHA-384/512 checksum result
+ * \param is384    0 = use SHA512, 1 = use SHA384
+ */
+void sha512( const unsigned char *input, size_t ilen,
+             unsigned char output[64], int is384 );
+
+/**
+ * \brief          Output = SHA-512( file contents )
+ *
+ * \param path     input file name
+ * \param output   SHA-384/512 checksum result
+ * \param is384    0 = use SHA512, 1 = use SHA384
+ *
+ * \return         0 if successful, or POLARSSL_ERR_SHA512_FILE_IO_ERROR
+ */
+int sha512_file( const char *path, unsigned char output[64], int is384 );
+
+/**
+ * \brief          SHA-512 HMAC context setup
+ *
+ * \param ctx      HMAC context to be initialized
+ * \param is384    0 = use SHA512, 1 = use SHA384
+ * \param key      HMAC secret key
+ * \param keylen   length of the HMAC key
+ */
+void sha512_hmac_starts( sha512_context *ctx, const unsigned char *key,
+                         size_t keylen, int is384 );
+
+/**
+ * \brief          SHA-512 HMAC process buffer
+ *
+ * \param ctx      HMAC context
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ */
+void sha512_hmac_update( sha512_context *ctx, const unsigned char *input,
+                         size_t ilen );
+
+/**
+ * \brief          SHA-512 HMAC final digest
+ *
+ * \param ctx      HMAC context
+ * \param output   SHA-384/512 HMAC checksum result
+ */
+void sha512_hmac_finish( sha512_context *ctx, unsigned char output[64] );
+
+/**
+ * \brief          SHA-512 HMAC context reset
+ *
+ * \param ctx      HMAC context to be reset
+ */
+void sha512_hmac_reset( sha512_context *ctx );
+
+/**
+ * \brief          Output = HMAC-SHA-512( hmac key, input buffer )
+ *
+ * \param key      HMAC secret key
+ * \param keylen   length of the HMAC key
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ * \param output   HMAC-SHA-384/512 result
+ * \param is384    0 = use SHA512, 1 = use SHA384
+ */
+void sha512_hmac( const unsigned char *key, size_t keylen,
+                const unsigned char *input, size_t ilen,
+                unsigned char output[64], int is384 );
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ */
+int sha512_self_test( int verbose );
+
+/* Internal use */
+void sha512_process( sha512_context *ctx, const unsigned char data[128] );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sha512.h */
diff --git a/util_lib/sha1.c b/util_lib/sha1.c
new file mode 100644
index 0000000..da18c78
--- /dev/null
+++ b/util_lib/sha1.c
@@ -0,0 +1,385 @@
+/*
+ *  FIPS-180-1 compliant SHA-1 implementation
+ *
+ *  Copyright (C) 2001-2003  Christophe Devine
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <string.h>
+
+#include "sha1.h"
+
+#define GET_UINT32(n,b,i)                       \
+{                                               \
+    (n) = ( (uint32_t) (b)[(i)    ] << 24 )       \
+        | ( (uint32_t) (b)[(i) + 1] << 16 )       \
+        | ( (uint32_t) (b)[(i) + 2] <<  8 )       \
+        | ( (uint32_t) (b)[(i) + 3]       );      \
+}
+
+#define PUT_UINT32(n,b,i)                       \
+{                                               \
+    (b)[(i)    ] = (uint8_t) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (uint8_t) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (uint8_t) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (uint8_t) ( (n)       );       \
+}
+
+void sha1_starts( sha1_context *ctx )
+{
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    ctx->state[0] = 0x67452301;
+    ctx->state[1] = 0xEFCDAB89;
+    ctx->state[2] = 0x98BADCFE;
+    ctx->state[3] = 0x10325476;
+    ctx->state[4] = 0xC3D2E1F0;
+}
+
+void sha1_process( sha1_context *ctx, const uint8_t data[64] )
+{
+    uint32_t temp, W[16], A, B, C, D, E;
+
+    GET_UINT32( W[0],  data,  0 );
+    GET_UINT32( W[1],  data,  4 );
+    GET_UINT32( W[2],  data,  8 );
+    GET_UINT32( W[3],  data, 12 );
+    GET_UINT32( W[4],  data, 16 );
+    GET_UINT32( W[5],  data, 20 );
+    GET_UINT32( W[6],  data, 24 );
+    GET_UINT32( W[7],  data, 28 );
+    GET_UINT32( W[8],  data, 32 );
+    GET_UINT32( W[9],  data, 36 );
+    GET_UINT32( W[10], data, 40 );
+    GET_UINT32( W[11], data, 44 );
+    GET_UINT32( W[12], data, 48 );
+    GET_UINT32( W[13], data, 52 );
+    GET_UINT32( W[14], data, 56 );
+    GET_UINT32( W[15], data, 60 );
+
+#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+
+#define R(t)                                            \
+(                                                       \
+    temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \
+           W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \
+    ( W[t & 0x0F] = S(temp,1) )                         \
+)
+
+#define P(a,b,c,d,e,x)                                  \
+{                                                       \
+    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
+}
+
+    A = ctx->state[0];
+    B = ctx->state[1];
+    C = ctx->state[2];
+    D = ctx->state[3];
+    E = ctx->state[4];
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+    P( A, B, C, D, E, W[0]  );
+    P( E, A, B, C, D, W[1]  );
+    P( D, E, A, B, C, W[2]  );
+    P( C, D, E, A, B, W[3]  );
+    P( B, C, D, E, A, W[4]  );
+    P( A, B, C, D, E, W[5]  );
+    P( E, A, B, C, D, W[6]  );
+    P( D, E, A, B, C, W[7]  );
+    P( C, D, E, A, B, W[8]  );
+    P( B, C, D, E, A, W[9]  );
+    P( A, B, C, D, E, W[10] );
+    P( E, A, B, C, D, W[11] );
+    P( D, E, A, B, C, W[12] );
+    P( C, D, E, A, B, W[13] );
+    P( B, C, D, E, A, W[14] );
+    P( A, B, C, D, E, W[15] );
+    P( E, A, B, C, D, R(16) );
+    P( D, E, A, B, C, R(17) );
+    P( C, D, E, A, B, R(18) );
+    P( B, C, D, E, A, R(19) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+    P( A, B, C, D, E, R(20) );
+    P( E, A, B, C, D, R(21) );
+    P( D, E, A, B, C, R(22) );
+    P( C, D, E, A, B, R(23) );
+    P( B, C, D, E, A, R(24) );
+    P( A, B, C, D, E, R(25) );
+    P( E, A, B, C, D, R(26) );
+    P( D, E, A, B, C, R(27) );
+    P( C, D, E, A, B, R(28) );
+    P( B, C, D, E, A, R(29) );
+    P( A, B, C, D, E, R(30) );
+    P( E, A, B, C, D, R(31) );
+    P( D, E, A, B, C, R(32) );
+    P( C, D, E, A, B, R(33) );
+    P( B, C, D, E, A, R(34) );
+    P( A, B, C, D, E, R(35) );
+    P( E, A, B, C, D, R(36) );
+    P( D, E, A, B, C, R(37) );
+    P( C, D, E, A, B, R(38) );
+    P( B, C, D, E, A, R(39) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+    P( A, B, C, D, E, R(40) );
+    P( E, A, B, C, D, R(41) );
+    P( D, E, A, B, C, R(42) );
+    P( C, D, E, A, B, R(43) );
+    P( B, C, D, E, A, R(44) );
+    P( A, B, C, D, E, R(45) );
+    P( E, A, B, C, D, R(46) );
+    P( D, E, A, B, C, R(47) );
+    P( C, D, E, A, B, R(48) );
+    P( B, C, D, E, A, R(49) );
+    P( A, B, C, D, E, R(50) );
+    P( E, A, B, C, D, R(51) );
+    P( D, E, A, B, C, R(52) );
+    P( C, D, E, A, B, R(53) );
+    P( B, C, D, E, A, R(54) );
+    P( A, B, C, D, E, R(55) );
+    P( E, A, B, C, D, R(56) );
+    P( D, E, A, B, C, R(57) );
+    P( C, D, E, A, B, R(58) );
+    P( B, C, D, E, A, R(59) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+    P( A, B, C, D, E, R(60) );
+    P( E, A, B, C, D, R(61) );
+    P( D, E, A, B, C, R(62) );
+    P( C, D, E, A, B, R(63) );
+    P( B, C, D, E, A, R(64) );
+    P( A, B, C, D, E, R(65) );
+    P( E, A, B, C, D, R(66) );
+    P( D, E, A, B, C, R(67) );
+    P( C, D, E, A, B, R(68) );
+    P( B, C, D, E, A, R(69) );
+    P( A, B, C, D, E, R(70) );
+    P( E, A, B, C, D, R(71) );
+    P( D, E, A, B, C, R(72) );
+    P( C, D, E, A, B, R(73) );
+    P( B, C, D, E, A, R(74) );
+    P( A, B, C, D, E, R(75) );
+    P( E, A, B, C, D, R(76) );
+    P( D, E, A, B, C, R(77) );
+    P( C, D, E, A, B, R(78) );
+    P( B, C, D, E, A, R(79) );
+
+#undef K
+#undef F
+
+    ctx->state[0] += A;
+    ctx->state[1] += B;
+    ctx->state[2] += C;
+    ctx->state[3] += D;
+    ctx->state[4] += E;
+}
+
+void sha1_update( sha1_context *ctx, const uint8_t *input, uint32_t length )
+{
+    uint32_t left, fill;
+
+    if( ! length ) return;
+
+    left = ctx->total[0] & 0x3F;
+    fill = 64 - left;
+
+    ctx->total[0] += length;
+    ctx->total[0] &= 0xFFFFFFFF;
+
+    if( ctx->total[0] < length )
+        ctx->total[1]++;
+
+    if( left && length >= fill )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (const void *) input, fill );
+        sha1_process( ctx, ctx->buffer );
+        length -= fill;
+        input  += fill;
+        left = 0;
+    }
+
+    while( length >= 64 )
+    {
+        sha1_process( ctx, input );
+        length -= 64;
+        input  += 64;
+    }
+
+    if( length )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, length );
+    }
+}
+
+static uint8_t sha1_padding[64] =
+{
+ 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+void sha1_finish( sha1_context *ctx, uint8_t digest[SHA1_DIGEST_LENGTH] )
+{
+    uint32_t last, padn;
+    uint32_t high, low;
+    uint8_t msglen[8];
+
+    high = ( ctx->total[0] >> 29 )
+         | ( ctx->total[1] <<  3 );
+    low  = ( ctx->total[0] <<  3 );
+
+    PUT_UINT32( high, msglen, 0 );
+    PUT_UINT32( low,  msglen, 4 );
+
+    last = ctx->total[0] & 0x3F;
+    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
+
+    sha1_update( ctx, sha1_padding, padn );
+    sha1_update( ctx, msglen, 8 );
+
+    PUT_UINT32( ctx->state[0], digest,  0 );
+    PUT_UINT32( ctx->state[1], digest,  4 );
+    PUT_UINT32( ctx->state[2], digest,  8 );
+    PUT_UINT32( ctx->state[3], digest, 12 );
+    PUT_UINT32( ctx->state[4], digest, 16 );
+}
+
+#ifdef TEST
+
+#include <stdlib.h>
+#include <stdio.h>
+
+/*
+ * those are the standard FIPS-180-1 test vectors
+ */
+
+static char *msg[] = 
+{
+    "abc",
+    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+    NULL
+};
+
+static char *val[] =
+{
+    "a9993e364706816aba3e25717850c26c9cd0d89d",
+    "84983e441c3bd26ebaae4aa1f95129e5e54670f1",
+    "34aa973cd4c4daa4f61eeb2bdbad27316534016f"
+};
+
+int main( int argc, char *argv[] )
+{
+    FILE *f;
+    int i, j;
+    char output[41];
+    sha1_context ctx;
+    unsigned char buf[1000];
+    unsigned char sha1sum[20];
+
+    if( argc < 2 )
+    {
+        printf( "\n SHA-1 Validation Tests:\n\n" );
+
+        for( i = 0; i < 3; i++ )
+        {
+            printf( " Test %d ", i + 1 );
+
+            sha1_starts( &ctx );
+
+            if( i < 2 )
+            {
+                sha1_update( &ctx, (uint8_t *) msg[i],
+                             strlen( msg[i] ) );
+            }
+            else
+            {
+                memset( buf, 'a', 1000 );
+
+                for( j = 0; j < 1000; j++ )
+                {
+                    sha1_update( &ctx, (uint8_t *) buf, 1000 );
+                }
+            }
+
+            sha1_finish( &ctx, sha1sum );
+
+            for( j = 0; j < 20; j++ )
+            {
+                sprintf( output + j * 2, "%02x", sha1sum[j] );
+            }
+
+            if( memcmp( output, val[i], 40 ) )
+            {
+                printf( "failed!\n" );
+                return( 1 );
+            }
+
+            printf( "passed.\n" );
+        }
+
+        printf( "\n" );
+    }
+    else
+    {
+        if( ! ( f = fopen( argv[1], "rb" ) ) )
+        {
+            perror( "fopen" );
+            return( 1 );
+        }
+
+        sha1_starts( &ctx );
+
+        while( ( i = fread( buf, 1, sizeof( buf ), f ) ) > 0 )
+        {
+            sha1_update( &ctx, buf, i );
+        }
+
+        sha1_finish( &ctx, sha1sum );
+
+        for( j = 0; j < 20; j++ )
+        {
+            printf( "%02x", sha1sum[j] );
+        }
+
+        printf( "  %s\n", argv[1] );
+    }
+
+    return( 0 );
+}
+
+#endif
diff --git a/util_lib/sha512.c b/util_lib/sha512.c
new file mode 100644
index 0000000..3f2a5b7
--- /dev/null
+++ b/util_lib/sha512.c
@@ -0,0 +1,794 @@
+/*
+ *  FIPS-180-2 compliant SHA-384/512 implementation
+ *
+ *  Copyright (C) 2006-2014, ARM Limited, All Rights Reserved
+ *
+ *  This file is part of mbed TLS (https://tls.mbed.org)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+/*
+ *  The SHA-512 Secure Hash Standard was published by NIST in 2002.
+ *
+ *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
+ */
+
+#include "sha512.h"
+
+#if defined(_MSC_VER) || defined(__WATCOMC__)
+  #define UL64(x) x##ui64
+#else
+  #define UL64(x) x##ULL
+#endif
+
+#include <string.h>
+
+#if defined(POLARSSL_FS_IO)
+#include <stdio.h>
+#endif
+
+#if defined(POLARSSL_SELF_TEST)
+#if defined(POLARSSL_PLATFORM_C)
+#include "polarssl/platform.h"
+#else
+#include <stdio.h>
+#define polarssl_printf printf
+#endif /* POLARSSL_PLATFORM_C */
+#endif /* POLARSSL_SELF_TEST */
+
+/* Implementation that should never be optimized out by the compiler */
+static void polarssl_zeroize( void *v, size_t n ) {
+    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
+}
+
+#if !defined(POLARSSL_SHA512_ALT)
+
+/*
+ * 64-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT64_BE
+#define GET_UINT64_BE(n,b,i)                            \
+{                                                       \
+    (n) = ( (uint64_t) (b)[(i)    ] << 56 )       \
+        | ( (uint64_t) (b)[(i) + 1] << 48 )       \
+        | ( (uint64_t) (b)[(i) + 2] << 40 )       \
+        | ( (uint64_t) (b)[(i) + 3] << 32 )       \
+        | ( (uint64_t) (b)[(i) + 4] << 24 )       \
+        | ( (uint64_t) (b)[(i) + 5] << 16 )       \
+        | ( (uint64_t) (b)[(i) + 6] <<  8 )       \
+        | ( (uint64_t) (b)[(i) + 7]       );      \
+}
+#endif /* GET_UINT64_BE */
+
+#ifndef PUT_UINT64_BE
+#define PUT_UINT64_BE(n,b,i)                            \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 56 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 48 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >> 40 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n) >> 32 );       \
+    (b)[(i) + 4] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 5] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 6] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 7] = (unsigned char) ( (n)       );       \
+}
+#endif /* PUT_UINT64_BE */
+
+/*
+ * Round constants
+ */
+static const uint64_t K[80] =
+{
+    UL64(0x428A2F98D728AE22),  UL64(0x7137449123EF65CD),
+    UL64(0xB5C0FBCFEC4D3B2F),  UL64(0xE9B5DBA58189DBBC),
+    UL64(0x3956C25BF348B538),  UL64(0x59F111F1B605D019),
+    UL64(0x923F82A4AF194F9B),  UL64(0xAB1C5ED5DA6D8118),
+    UL64(0xD807AA98A3030242),  UL64(0x12835B0145706FBE),
+    UL64(0x243185BE4EE4B28C),  UL64(0x550C7DC3D5FFB4E2),
+    UL64(0x72BE5D74F27B896F),  UL64(0x80DEB1FE3B1696B1),
+    UL64(0x9BDC06A725C71235),  UL64(0xC19BF174CF692694),
+    UL64(0xE49B69C19EF14AD2),  UL64(0xEFBE4786384F25E3),
+    UL64(0x0FC19DC68B8CD5B5),  UL64(0x240CA1CC77AC9C65),
+    UL64(0x2DE92C6F592B0275),  UL64(0x4A7484AA6EA6E483),
+    UL64(0x5CB0A9DCBD41FBD4),  UL64(0x76F988DA831153B5),
+    UL64(0x983E5152EE66DFAB),  UL64(0xA831C66D2DB43210),
+    UL64(0xB00327C898FB213F),  UL64(0xBF597FC7BEEF0EE4),
+    UL64(0xC6E00BF33DA88FC2),  UL64(0xD5A79147930AA725),
+    UL64(0x06CA6351E003826F),  UL64(0x142929670A0E6E70),
+    UL64(0x27B70A8546D22FFC),  UL64(0x2E1B21385C26C926),
+    UL64(0x4D2C6DFC5AC42AED),  UL64(0x53380D139D95B3DF),
+    UL64(0x650A73548BAF63DE),  UL64(0x766A0ABB3C77B2A8),
+    UL64(0x81C2C92E47EDAEE6),  UL64(0x92722C851482353B),
+    UL64(0xA2BFE8A14CF10364),  UL64(0xA81A664BBC423001),
+    UL64(0xC24B8B70D0F89791),  UL64(0xC76C51A30654BE30),
+    UL64(0xD192E819D6EF5218),  UL64(0xD69906245565A910),
+    UL64(0xF40E35855771202A),  UL64(0x106AA07032BBD1B8),
+    UL64(0x19A4C116B8D2D0C8),  UL64(0x1E376C085141AB53),
+    UL64(0x2748774CDF8EEB99),  UL64(0x34B0BCB5E19B48A8),
+    UL64(0x391C0CB3C5C95A63),  UL64(0x4ED8AA4AE3418ACB),
+    UL64(0x5B9CCA4F7763E373),  UL64(0x682E6FF3D6B2B8A3),
+    UL64(0x748F82EE5DEFB2FC),  UL64(0x78A5636F43172F60),
+    UL64(0x84C87814A1F0AB72),  UL64(0x8CC702081A6439EC),
+    UL64(0x90BEFFFA23631E28),  UL64(0xA4506CEBDE82BDE9),
+    UL64(0xBEF9A3F7B2C67915),  UL64(0xC67178F2E372532B),
+    UL64(0xCA273ECEEA26619C),  UL64(0xD186B8C721C0C207),
+    UL64(0xEADA7DD6CDE0EB1E),  UL64(0xF57D4F7FEE6ED178),
+    UL64(0x06F067AA72176FBA),  UL64(0x0A637DC5A2C898A6),
+    UL64(0x113F9804BEF90DAE),  UL64(0x1B710B35131C471B),
+    UL64(0x28DB77F523047D84),  UL64(0x32CAAB7B40C72493),
+    UL64(0x3C9EBE0A15C9BEBC),  UL64(0x431D67C49C100D4C),
+    UL64(0x4CC5D4BECB3E42B6),  UL64(0x597F299CFC657E2A),
+    UL64(0x5FCB6FAB3AD6FAEC),  UL64(0x6C44198C4A475817)
+};
+
+void sha512_init( sha512_context *ctx )
+{
+    memset( ctx, 0, sizeof( sha512_context ) );
+}
+
+void sha512_free( sha512_context *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+    polarssl_zeroize( ctx, sizeof( sha512_context ) );
+}
+
+/*
+ * SHA-512 context setup
+ */
+void sha512_starts( sha512_context *ctx, int is384 )
+{
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    if( is384 == 0 )
+    {
+        /* SHA-512 */
+        ctx->state[0] = UL64(0x6A09E667F3BCC908);
+        ctx->state[1] = UL64(0xBB67AE8584CAA73B);
+        ctx->state[2] = UL64(0x3C6EF372FE94F82B);
+        ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
+        ctx->state[4] = UL64(0x510E527FADE682D1);
+        ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
+        ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
+        ctx->state[7] = UL64(0x5BE0CD19137E2179);
+    }
+    else
+    {
+        /* SHA-384 */
+        ctx->state[0] = UL64(0xCBBB9D5DC1059ED8);
+        ctx->state[1] = UL64(0x629A292A367CD507);
+        ctx->state[2] = UL64(0x9159015A3070DD17);
+        ctx->state[3] = UL64(0x152FECD8F70E5939);
+        ctx->state[4] = UL64(0x67332667FFC00B31);
+        ctx->state[5] = UL64(0x8EB44A8768581511);
+        ctx->state[6] = UL64(0xDB0C2E0D64F98FA7);
+        ctx->state[7] = UL64(0x47B5481DBEFA4FA4);
+    }
+
+    ctx->is384 = is384;
+}
+
+void sha512_process( sha512_context *ctx, const unsigned char data[128] )
+{
+    int i;
+    uint64_t temp1, temp2, W[80];
+    uint64_t A, B, C, D, E, F, G, H;
+
+#define  SHR(x,n) (x >> n)
+#define ROTR(x,n) (SHR(x,n) | (x << (64 - n)))
+
+#define S0(x) (ROTR(x, 1) ^ ROTR(x, 8) ^  SHR(x, 7))
+#define S1(x) (ROTR(x,19) ^ ROTR(x,61) ^  SHR(x, 6))
+
+#define S2(x) (ROTR(x,28) ^ ROTR(x,34) ^ ROTR(x,39))
+#define S3(x) (ROTR(x,14) ^ ROTR(x,18) ^ ROTR(x,41))
+
+#define F0(x,y,z) ((x & y) | (z & (x | y)))
+#define F1(x,y,z) (z ^ (x & (y ^ z)))
+
+#define P(a,b,c,d,e,f,g,h,x,K)                  \
+{                                               \
+    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
+    temp2 = S2(a) + F0(a,b,c);                  \
+    d += temp1; h = temp1 + temp2;              \
+}
+
+    for( i = 0; i < 16; i++ )
+    {
+        GET_UINT64_BE( W[i], data, i << 3 );
+    }
+
+    for( ; i < 80; i++ )
+    {
+        W[i] = S1(W[i -  2]) + W[i -  7] +
+               S0(W[i - 15]) + W[i - 16];
+    }
+
+    A = ctx->state[0];
+    B = ctx->state[1];
+    C = ctx->state[2];
+    D = ctx->state[3];
+    E = ctx->state[4];
+    F = ctx->state[5];
+    G = ctx->state[6];
+    H = ctx->state[7];
+    i = 0;
+
+    do
+    {
+        P( A, B, C, D, E, F, G, H, W[i], K[i] ); i++;
+        P( H, A, B, C, D, E, F, G, W[i], K[i] ); i++;
+        P( G, H, A, B, C, D, E, F, W[i], K[i] ); i++;
+        P( F, G, H, A, B, C, D, E, W[i], K[i] ); i++;
+        P( E, F, G, H, A, B, C, D, W[i], K[i] ); i++;
+        P( D, E, F, G, H, A, B, C, W[i], K[i] ); i++;
+        P( C, D, E, F, G, H, A, B, W[i], K[i] ); i++;
+        P( B, C, D, E, F, G, H, A, W[i], K[i] ); i++;
+    }
+    while( i < 80 );
+
+    ctx->state[0] += A;
+    ctx->state[1] += B;
+    ctx->state[2] += C;
+    ctx->state[3] += D;
+    ctx->state[4] += E;
+    ctx->state[5] += F;
+    ctx->state[6] += G;
+    ctx->state[7] += H;
+}
+
+/*
+ * SHA-512 process buffer
+ */
+void sha512_update( sha512_context *ctx, const unsigned char *input,
+                    size_t ilen )
+{
+    size_t fill;
+    unsigned int left;
+
+    if( ilen == 0 )
+        return;
+
+    left = (unsigned int) (ctx->total[0] & 0x7F);
+    fill = 128 - left;
+
+    ctx->total[0] += (uint64_t) ilen;
+
+    if( ctx->total[0] < (uint64_t) ilen )
+        ctx->total[1]++;
+
+    if( left && ilen >= fill )
+    {
+        memcpy( (void *) (ctx->buffer + left), input, fill );
+        sha512_process( ctx, ctx->buffer );
+        input += fill;
+        ilen  -= fill;
+        left = 0;
+    }
+
+    while( ilen >= 128 )
+    {
+        sha512_process( ctx, input );
+        input += 128;
+        ilen  -= 128;
+    }
+
+    if( ilen > 0 )
+        memcpy( (void *) (ctx->buffer + left), input, ilen );
+}
+
+static const unsigned char sha512_padding[128] =
+{
+ 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * SHA-512 final digest
+ */
+void sha512_finish( sha512_context *ctx, unsigned char output[64] )
+{
+    size_t last, padn;
+    uint64_t high, low;
+    unsigned char msglen[16];
+
+    high = ( ctx->total[0] >> 61 )
+         | ( ctx->total[1] <<  3 );
+    low  = ( ctx->total[0] <<  3 );
+
+    PUT_UINT64_BE( high, msglen, 0 );
+    PUT_UINT64_BE( low,  msglen, 8 );
+
+    last = (size_t)( ctx->total[0] & 0x7F );
+    padn = ( last < 112 ) ? ( 112 - last ) : ( 240 - last );
+
+    sha512_update( ctx, sha512_padding, padn );
+    sha512_update( ctx, msglen, 16 );
+
+    PUT_UINT64_BE( ctx->state[0], output,  0 );
+    PUT_UINT64_BE( ctx->state[1], output,  8 );
+    PUT_UINT64_BE( ctx->state[2], output, 16 );
+    PUT_UINT64_BE( ctx->state[3], output, 24 );
+    PUT_UINT64_BE( ctx->state[4], output, 32 );
+    PUT_UINT64_BE( ctx->state[5], output, 40 );
+
+    if( ctx->is384 == 0 )
+    {
+        PUT_UINT64_BE( ctx->state[6], output, 48 );
+        PUT_UINT64_BE( ctx->state[7], output, 56 );
+    }
+}
+
+#endif /* !POLARSSL_SHA512_ALT */
+
+/*
+ * output = SHA-512( input buffer )
+ */
+void sha512( const unsigned char *input, size_t ilen,
+             unsigned char output[64], int is384 )
+{
+    sha512_context ctx;
+
+    sha512_init( &ctx );
+    sha512_starts( &ctx, is384 );
+    sha512_update( &ctx, input, ilen );
+    sha512_finish( &ctx, output );
+    sha512_free( &ctx );
+}
+
+#if defined(POLARSSL_FS_IO)
+/*
+ * output = SHA-512( file contents )
+ */
+int sha512_file( const char *path, unsigned char output[64], int is384 )
+{
+    FILE *f;
+    size_t n;
+    sha512_context ctx;
+    unsigned char buf[1024];
+
+    if( ( f = fopen( path, "rb" ) ) == NULL )
+        return( POLARSSL_ERR_SHA512_FILE_IO_ERROR );
+
+    sha512_init( &ctx );
+    sha512_starts( &ctx, is384 );
+
+    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )
+        sha512_update( &ctx, buf, n );
+
+    sha512_finish( &ctx, output );
+    sha512_free( &ctx );
+
+    if( ferror( f ) != 0 )
+    {
+        fclose( f );
+        return( POLARSSL_ERR_SHA512_FILE_IO_ERROR );
+    }
+
+    fclose( f );
+    return( 0 );
+}
+#endif /* POLARSSL_FS_IO */
+
+/*
+ * SHA-512 HMAC context setup
+ */
+void sha512_hmac_starts( sha512_context *ctx, const unsigned char *key,
+                         size_t keylen, int is384 )
+{
+    size_t i;
+    unsigned char sum[64];
+
+    if( keylen > 128 )
+    {
+        sha512( key, keylen, sum, is384 );
+        keylen = ( is384 ) ? 48 : 64;
+        key = sum;
+    }
+
+    memset( ctx->ipad, 0x36, 128 );
+    memset( ctx->opad, 0x5C, 128 );
+
+    for( i = 0; i < keylen; i++ )
+    {
+        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );
+        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );
+    }
+
+    sha512_starts( ctx, is384 );
+    sha512_update( ctx, ctx->ipad, 128 );
+
+    polarssl_zeroize( sum, sizeof( sum ) );
+}
+
+/*
+ * SHA-512 HMAC process buffer
+ */
+void sha512_hmac_update( sha512_context  *ctx,
+                         const unsigned char *input, size_t ilen )
+{
+    sha512_update( ctx, input, ilen );
+}
+
+/*
+ * SHA-512 HMAC final digest
+ */
+void sha512_hmac_finish( sha512_context *ctx, unsigned char output[64] )
+{
+    int is384, hlen;
+    unsigned char tmpbuf[64];
+
+    is384 = ctx->is384;
+    hlen = ( is384 == 0 ) ? 64 : 48;
+
+    sha512_finish( ctx, tmpbuf );
+    sha512_starts( ctx, is384 );
+    sha512_update( ctx, ctx->opad, 128 );
+    sha512_update( ctx, tmpbuf, hlen );
+    sha512_finish( ctx, output );
+
+    polarssl_zeroize( tmpbuf, sizeof( tmpbuf ) );
+}
+
+/*
+ * SHA-512 HMAC context reset
+ */
+void sha512_hmac_reset( sha512_context *ctx )
+{
+    sha512_starts( ctx, ctx->is384 );
+    sha512_update( ctx, ctx->ipad, 128 );
+}
+
+/*
+ * output = HMAC-SHA-512( hmac key, input buffer )
+ */
+void sha512_hmac( const unsigned char *key, size_t keylen,
+                const unsigned char *input, size_t ilen,
+                unsigned char output[64], int is384 )
+{
+    sha512_context ctx;
+
+    sha512_init( &ctx );
+    sha512_hmac_starts( &ctx, key, keylen, is384 );
+    sha512_hmac_update( &ctx, input, ilen );
+    sha512_hmac_finish( &ctx, output );
+    sha512_free( &ctx );
+}
+
+#if defined(POLARSSL_SELF_TEST)
+
+/*
+ * FIPS-180-2 test vectors
+ */
+static const unsigned char sha512_test_buf[3][113] =
+{
+    { "abc" },
+    { "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
+      "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu" },
+    { "" }
+};
+
+static const int sha512_test_buflen[3] =
+{
+    3, 112, 1000
+};
+
+static const unsigned char sha512_test_sum[6][64] =
+{
+    /*
+     * SHA-384 test vectors
+     */
+    { 0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B,
+      0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07,
+      0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63,
+      0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED,
+      0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23,
+      0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7 },
+    { 0x09, 0x33, 0x0C, 0x33, 0xF7, 0x11, 0x47, 0xE8,
+      0x3D, 0x19, 0x2F, 0xC7, 0x82, 0xCD, 0x1B, 0x47,
+      0x53, 0x11, 0x1B, 0x17, 0x3B, 0x3B, 0x05, 0xD2,
+      0x2F, 0xA0, 0x80, 0x86, 0xE3, 0xB0, 0xF7, 0x12,
+      0xFC, 0xC7, 0xC7, 0x1A, 0x55, 0x7E, 0x2D, 0xB9,
+      0x66, 0xC3, 0xE9, 0xFA, 0x91, 0x74, 0x60, 0x39 },
+    { 0x9D, 0x0E, 0x18, 0x09, 0x71, 0x64, 0x74, 0xCB,
+      0x08, 0x6E, 0x83, 0x4E, 0x31, 0x0A, 0x4A, 0x1C,
+      0xED, 0x14, 0x9E, 0x9C, 0x00, 0xF2, 0x48, 0x52,
+      0x79, 0x72, 0xCE, 0xC5, 0x70, 0x4C, 0x2A, 0x5B,
+      0x07, 0xB8, 0xB3, 0xDC, 0x38, 0xEC, 0xC4, 0xEB,
+      0xAE, 0x97, 0xDD, 0xD8, 0x7F, 0x3D, 0x89, 0x85 },
+
+    /*
+     * SHA-512 test vectors
+     */
+    { 0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA,
+      0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31,
+      0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2,
+      0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A,
+      0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8,
+      0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD,
+      0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E,
+      0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F },
+    { 0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA,
+      0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F,
+      0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1,
+      0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18,
+      0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4,
+      0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A,
+      0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54,
+      0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09 },
+    { 0xE7, 0x18, 0x48, 0x3D, 0x0C, 0xE7, 0x69, 0x64,
+      0x4E, 0x2E, 0x42, 0xC7, 0xBC, 0x15, 0xB4, 0x63,
+      0x8E, 0x1F, 0x98, 0xB1, 0x3B, 0x20, 0x44, 0x28,
+      0x56, 0x32, 0xA8, 0x03, 0xAF, 0xA9, 0x73, 0xEB,
+      0xDE, 0x0F, 0xF2, 0x44, 0x87, 0x7E, 0xA6, 0x0A,
+      0x4C, 0xB0, 0x43, 0x2C, 0xE5, 0x77, 0xC3, 0x1B,
+      0xEB, 0x00, 0x9C, 0x5C, 0x2C, 0x49, 0xAA, 0x2E,
+      0x4E, 0xAD, 0xB2, 0x17, 0xAD, 0x8C, 0xC0, 0x9B }
+};
+
+/*
+ * RFC 4231 test vectors
+ */
+static const unsigned char sha512_hmac_test_key[7][26] =
+{
+    { "\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B"
+      "\x0B\x0B\x0B\x0B" },
+    { "Jefe" },
+    { "\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"
+      "\xAA\xAA\xAA\xAA" },
+    { "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
+      "\x11\x12\x13\x14\x15\x16\x17\x18\x19" },
+    { "\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C"
+      "\x0C\x0C\x0C\x0C" },
+    { "" }, /* 0xAA 131 times */
+    { "" }
+};
+
+static const int sha512_hmac_test_keylen[7] =
+{
+    20, 4, 20, 25, 20, 131, 131
+};
+
+static const unsigned char sha512_hmac_test_buf[7][153] =
+{
+    { "Hi There" },
+    { "what do ya want for nothing?" },
+    { "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
+      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
+      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
+      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
+      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD" },
+    { "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" },
+    { "Test With Truncation" },
+    { "Test Using Larger Than Block-Size Key - Hash Key First" },
+    { "This is a test using a larger than block-size key "
+      "and a larger than block-size data. The key needs to "
+      "be hashed before being used by the HMAC algorithm." }
+};
+
+static const int sha512_hmac_test_buflen[7] =
+{
+    8, 28, 50, 50, 20, 54, 152
+};
+
+static const unsigned char sha512_hmac_test_sum[14][64] =
+{
+    /*
+     * HMAC-SHA-384 test vectors
+     */
+    { 0xAF, 0xD0, 0x39, 0x44, 0xD8, 0x48, 0x95, 0x62,
+      0x6B, 0x08, 0x25, 0xF4, 0xAB, 0x46, 0x90, 0x7F,
+      0x15, 0xF9, 0xDA, 0xDB, 0xE4, 0x10, 0x1E, 0xC6,
+      0x82, 0xAA, 0x03, 0x4C, 0x7C, 0xEB, 0xC5, 0x9C,
+      0xFA, 0xEA, 0x9E, 0xA9, 0x07, 0x6E, 0xDE, 0x7F,
+      0x4A, 0xF1, 0x52, 0xE8, 0xB2, 0xFA, 0x9C, 0xB6 },
+    { 0xAF, 0x45, 0xD2, 0xE3, 0x76, 0x48, 0x40, 0x31,
+      0x61, 0x7F, 0x78, 0xD2, 0xB5, 0x8A, 0x6B, 0x1B,
+      0x9C, 0x7E, 0xF4, 0x64, 0xF5, 0xA0, 0x1B, 0x47,
+      0xE4, 0x2E, 0xC3, 0x73, 0x63, 0x22, 0x44, 0x5E,
+      0x8E, 0x22, 0x40, 0xCA, 0x5E, 0x69, 0xE2, 0xC7,
+      0x8B, 0x32, 0x39, 0xEC, 0xFA, 0xB2, 0x16, 0x49 },
+    { 0x88, 0x06, 0x26, 0x08, 0xD3, 0xE6, 0xAD, 0x8A,
+      0x0A, 0xA2, 0xAC, 0xE0, 0x14, 0xC8, 0xA8, 0x6F,
+      0x0A, 0xA6, 0x35, 0xD9, 0x47, 0xAC, 0x9F, 0xEB,
+      0xE8, 0x3E, 0xF4, 0xE5, 0x59, 0x66, 0x14, 0x4B,
+      0x2A, 0x5A, 0xB3, 0x9D, 0xC1, 0x38, 0x14, 0xB9,
+      0x4E, 0x3A, 0xB6, 0xE1, 0x01, 0xA3, 0x4F, 0x27 },
+    { 0x3E, 0x8A, 0x69, 0xB7, 0x78, 0x3C, 0x25, 0x85,
+      0x19, 0x33, 0xAB, 0x62, 0x90, 0xAF, 0x6C, 0xA7,
+      0x7A, 0x99, 0x81, 0x48, 0x08, 0x50, 0x00, 0x9C,
+      0xC5, 0x57, 0x7C, 0x6E, 0x1F, 0x57, 0x3B, 0x4E,
+      0x68, 0x01, 0xDD, 0x23, 0xC4, 0xA7, 0xD6, 0x79,
+      0xCC, 0xF8, 0xA3, 0x86, 0xC6, 0x74, 0xCF, 0xFB },
+    { 0x3A, 0xBF, 0x34, 0xC3, 0x50, 0x3B, 0x2A, 0x23,
+      0xA4, 0x6E, 0xFC, 0x61, 0x9B, 0xAE, 0xF8, 0x97 },
+    { 0x4E, 0xCE, 0x08, 0x44, 0x85, 0x81, 0x3E, 0x90,
+      0x88, 0xD2, 0xC6, 0x3A, 0x04, 0x1B, 0xC5, 0xB4,
+      0x4F, 0x9E, 0xF1, 0x01, 0x2A, 0x2B, 0x58, 0x8F,
+      0x3C, 0xD1, 0x1F, 0x05, 0x03, 0x3A, 0xC4, 0xC6,
+      0x0C, 0x2E, 0xF6, 0xAB, 0x40, 0x30, 0xFE, 0x82,
+      0x96, 0x24, 0x8D, 0xF1, 0x63, 0xF4, 0x49, 0x52 },
+    { 0x66, 0x17, 0x17, 0x8E, 0x94, 0x1F, 0x02, 0x0D,
+      0x35, 0x1E, 0x2F, 0x25, 0x4E, 0x8F, 0xD3, 0x2C,
+      0x60, 0x24, 0x20, 0xFE, 0xB0, 0xB8, 0xFB, 0x9A,
+      0xDC, 0xCE, 0xBB, 0x82, 0x46, 0x1E, 0x99, 0xC5,
+      0xA6, 0x78, 0xCC, 0x31, 0xE7, 0x99, 0x17, 0x6D,
+      0x38, 0x60, 0xE6, 0x11, 0x0C, 0x46, 0x52, 0x3E },
+
+    /*
+     * HMAC-SHA-512 test vectors
+     */
+    { 0x87, 0xAA, 0x7C, 0xDE, 0xA5, 0xEF, 0x61, 0x9D,
+      0x4F, 0xF0, 0xB4, 0x24, 0x1A, 0x1D, 0x6C, 0xB0,
+      0x23, 0x79, 0xF4, 0xE2, 0xCE, 0x4E, 0xC2, 0x78,
+      0x7A, 0xD0, 0xB3, 0x05, 0x45, 0xE1, 0x7C, 0xDE,
+      0xDA, 0xA8, 0x33, 0xB7, 0xD6, 0xB8, 0xA7, 0x02,
+      0x03, 0x8B, 0x27, 0x4E, 0xAE, 0xA3, 0xF4, 0xE4,
+      0xBE, 0x9D, 0x91, 0x4E, 0xEB, 0x61, 0xF1, 0x70,
+      0x2E, 0x69, 0x6C, 0x20, 0x3A, 0x12, 0x68, 0x54 },
+    { 0x16, 0x4B, 0x7A, 0x7B, 0xFC, 0xF8, 0x19, 0xE2,
+      0xE3, 0x95, 0xFB, 0xE7, 0x3B, 0x56, 0xE0, 0xA3,
+      0x87, 0xBD, 0x64, 0x22, 0x2E, 0x83, 0x1F, 0xD6,
+      0x10, 0x27, 0x0C, 0xD7, 0xEA, 0x25, 0x05, 0x54,
+      0x97, 0x58, 0xBF, 0x75, 0xC0, 0x5A, 0x99, 0x4A,
+      0x6D, 0x03, 0x4F, 0x65, 0xF8, 0xF0, 0xE6, 0xFD,
+      0xCA, 0xEA, 0xB1, 0xA3, 0x4D, 0x4A, 0x6B, 0x4B,
+      0x63, 0x6E, 0x07, 0x0A, 0x38, 0xBC, 0xE7, 0x37 },
+    { 0xFA, 0x73, 0xB0, 0x08, 0x9D, 0x56, 0xA2, 0x84,
+      0xEF, 0xB0, 0xF0, 0x75, 0x6C, 0x89, 0x0B, 0xE9,
+      0xB1, 0xB5, 0xDB, 0xDD, 0x8E, 0xE8, 0x1A, 0x36,
+      0x55, 0xF8, 0x3E, 0x33, 0xB2, 0x27, 0x9D, 0x39,
+      0xBF, 0x3E, 0x84, 0x82, 0x79, 0xA7, 0x22, 0xC8,
+      0x06, 0xB4, 0x85, 0xA4, 0x7E, 0x67, 0xC8, 0x07,
+      0xB9, 0x46, 0xA3, 0x37, 0xBE, 0xE8, 0x94, 0x26,
+      0x74, 0x27, 0x88, 0x59, 0xE1, 0x32, 0x92, 0xFB },
+    { 0xB0, 0xBA, 0x46, 0x56, 0x37, 0x45, 0x8C, 0x69,
+      0x90, 0xE5, 0xA8, 0xC5, 0xF6, 0x1D, 0x4A, 0xF7,
+      0xE5, 0x76, 0xD9, 0x7F, 0xF9, 0x4B, 0x87, 0x2D,
+      0xE7, 0x6F, 0x80, 0x50, 0x36, 0x1E, 0xE3, 0xDB,
+      0xA9, 0x1C, 0xA5, 0xC1, 0x1A, 0xA2, 0x5E, 0xB4,
+      0xD6, 0x79, 0x27, 0x5C, 0xC5, 0x78, 0x80, 0x63,
+      0xA5, 0xF1, 0x97, 0x41, 0x12, 0x0C, 0x4F, 0x2D,
+      0xE2, 0xAD, 0xEB, 0xEB, 0x10, 0xA2, 0x98, 0xDD },
+    { 0x41, 0x5F, 0xAD, 0x62, 0x71, 0x58, 0x0A, 0x53,
+      0x1D, 0x41, 0x79, 0xBC, 0x89, 0x1D, 0x87, 0xA6 },
+    { 0x80, 0xB2, 0x42, 0x63, 0xC7, 0xC1, 0xA3, 0xEB,
+      0xB7, 0x14, 0x93, 0xC1, 0xDD, 0x7B, 0xE8, 0xB4,
+      0x9B, 0x46, 0xD1, 0xF4, 0x1B, 0x4A, 0xEE, 0xC1,
+      0x12, 0x1B, 0x01, 0x37, 0x83, 0xF8, 0xF3, 0x52,
+      0x6B, 0x56, 0xD0, 0x37, 0xE0, 0x5F, 0x25, 0x98,
+      0xBD, 0x0F, 0xD2, 0x21, 0x5D, 0x6A, 0x1E, 0x52,
+      0x95, 0xE6, 0x4F, 0x73, 0xF6, 0x3F, 0x0A, 0xEC,
+      0x8B, 0x91, 0x5A, 0x98, 0x5D, 0x78, 0x65, 0x98 },
+    { 0xE3, 0x7B, 0x6A, 0x77, 0x5D, 0xC8, 0x7D, 0xBA,
+      0xA4, 0xDF, 0xA9, 0xF9, 0x6E, 0x5E, 0x3F, 0xFD,
+      0xDE, 0xBD, 0x71, 0xF8, 0x86, 0x72, 0x89, 0x86,
+      0x5D, 0xF5, 0xA3, 0x2D, 0x20, 0xCD, 0xC9, 0x44,
+      0xB6, 0x02, 0x2C, 0xAC, 0x3C, 0x49, 0x82, 0xB1,
+      0x0D, 0x5E, 0xEB, 0x55, 0xC3, 0xE4, 0xDE, 0x15,
+      0x13, 0x46, 0x76, 0xFB, 0x6D, 0xE0, 0x44, 0x60,
+      0x65, 0xC9, 0x74, 0x40, 0xFA, 0x8C, 0x6A, 0x58 }
+};
+
+/*
+ * Checkup routine
+ */
+int sha512_self_test( int verbose )
+{
+    int i, j, k, buflen, ret = 0;
+    unsigned char buf[1024];
+    unsigned char sha512sum[64];
+    sha512_context ctx;
+
+    sha512_init( &ctx );
+
+    for( i = 0; i < 6; i++ )
+    {
+        j = i % 3;
+        k = i < 3;
+
+        if( verbose != 0 )
+            polarssl_printf( "  SHA-%d test #%d: ", 512 - k * 128, j + 1 );
+
+        sha512_starts( &ctx, k );
+
+        if( j == 2 )
+        {
+            memset( buf, 'a', buflen = 1000 );
+
+            for( j = 0; j < 1000; j++ )
+                sha512_update( &ctx, buf, buflen );
+        }
+        else
+            sha512_update( &ctx, sha512_test_buf[j],
+                                 sha512_test_buflen[j] );
+
+        sha512_finish( &ctx, sha512sum );
+
+        if( memcmp( sha512sum, sha512_test_sum[i], 64 - k * 16 ) != 0 )
+        {
+            if( verbose != 0 )
+                polarssl_printf( "failed\n" );
+
+            ret = 1;
+            goto exit;
+        }
+
+        if( verbose != 0 )
+            polarssl_printf( "passed\n" );
+    }
+
+    if( verbose != 0 )
+        polarssl_printf( "\n" );
+
+    for( i = 0; i < 14; i++ )
+    {
+        j = i % 7;
+        k = i < 7;
+
+        if( verbose != 0 )
+            polarssl_printf( "  HMAC-SHA-%d test #%d: ", 512 - k * 128, j + 1 );
+
+        if( j == 5 || j == 6 )
+        {
+            memset( buf, 0xAA, buflen = 131 );
+            sha512_hmac_starts( &ctx, buf, buflen, k );
+        }
+        else
+            sha512_hmac_starts( &ctx, sha512_hmac_test_key[j],
+                                      sha512_hmac_test_keylen[j], k );
+
+        sha512_hmac_update( &ctx, sha512_hmac_test_buf[j],
+                                  sha512_hmac_test_buflen[j] );
+
+        sha512_hmac_finish( &ctx, sha512sum );
+
+        buflen = ( j == 4 ) ? 16 : 64 - k * 16;
+
+        if( memcmp( sha512sum, sha512_hmac_test_sum[i], buflen ) != 0 )
+        {
+            if( verbose != 0 )
+                polarssl_printf( "failed\n" );
+
+            ret = 1;
+            goto exit;
+        }
+
+        if( verbose != 0 )
+            polarssl_printf( "passed\n" );
+    }
+
+    if( verbose != 0 )
+        polarssl_printf( "\n" );
+
+exit:
+    sha512_free( &ctx );
+
+    return( ret );
+}
+
+#endif /* POLARSSL_SELF_TEST */
